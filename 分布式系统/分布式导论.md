# CAP原理

### C：Consistency（一致性）

* 特指**强一致**，即所有**节点数据时刻保持同步**
* 一致性的严谨表述为**原子读写**、或**串行读写**，即所有读写**看起来**应该是**“原子”**的，所有读写请求都是**经过全局排序过的**。
* **all nodes see the same data at the same time**，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。
* 不同角度：
  * 从**客户端**来看，一致性主要指的是**多并发访问时如何获取更新过的数据的问题**。
  * 从**服务端**来看，则是**更新如何复制分布到整个系统，以保证数据最终一致的问题**。
* 一致性是因为有**并发读写**才会存在的问题，因此我们在理解一致性的问题时，一定要注意结合考虑并发读写的场景。

### A：Availability（可用性）

* 所有**非故障节点**都应该**在有限时间内给出请求的响应**，不论请求是否成功。
* 可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如负载均衡、WEB服务器、应用代码、数据库服务器等，任何一个节点的不稳定都可以影响可用性。

### P：Tolerance to the partition of network（分区容忍性）

* 当**部分节点之间无法通信**时，在**丢失任意多消**息的情况下，系统仍能正常工作。
* 值得注意的是：**分布式系统中的网络分区在任何时刻、任何地点都有可能正在或即将发生！！！**

# CAP三者不可兼得

* 可以想象有两个节点处于系统的分区两侧

### 满足CP，不满足A

* 若要求满足一致性，则**当分区两侧出现数据不一致时，必须进行同步，从而对客户端请求的处理必须进行等待，而等待的时间不可知（因为分区间不可通信，这一时间会无限延长），从而失去了可用性。**
* 这种分布式系统，**一旦发生网络故障或者消息丢失等情况**，就要牺牲用户的体验，**等待所有数据全部一致**之后再让用户访问系统。
* 某些坚持**ACID原则**的**事务型数据库**有着对结果一致性非常敏感（**强一致**）的要求，会采用这种选择。

### 满足AP，不满足C

* 若允许**某一分区使用本地数据（或者单独更新该节点状态）**以提供**高可用服务**，那么就会导致**不同分区之间的数据不一致**，从而**失去了一致性**。
* 这种分布式系统，一旦**在网络问题发生、节点之间失去联系的情况下**，为了保证高可用，需要尽快响应用户的访问请求，则**每个节点只能用本地数据提供服务**，而这样**会导致全局数据的不一致性。**
* 某些信奉**BASE原则的NoSQL数据库**往往会采用此策略，以**放宽对一致性的要求**（即**弱一致**，满足**最终一致性**即可），来满足基本的可用性。

### 满足CA，不满足P

* 如果不存在分区容忍性，即保证**系统节点之间可以保证正常通信**，那么一致性和可用性自然可以同时满足。

### CAP的重新阐述

* 2012年，CAP原理提出者对CAP原理进行了重新阐述，明确指出：“**CAP原理只适用于原子读写的场景，而不支持数据库事务之类的场景**”。

# 一致性模型

* 参考网站：
  * 简书：https://www.jianshu.com/p/3673e612cce2（讲解了多种一致性模型，重点介绍事务一致性模型）
  * https://www.infoq.cn/article/2SdXit6XyCL36MQZ4ONa（重点讲解了各个数据一致性模型）
  * http://r12f.com/posts/summarizing-consistency-model/（以表格形式讲解了各个一致性模型）
  * https://www.infoq.cn/article/2SdXit6XyCL36MQZ4ONa（以图片方式形象详细地讲解了各个数据一致性模型）
  * https://int64.me/2020/%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0.html (较为形象、清晰地讲解了各个数据性一致性模型、可串行化一致性模型和一致性验证方法)
  * 知乎：https://zhuanlan.zhihu.com/p/71913226（详细讲解了因果一致性）
  * 知乎：https://zhuanlan.zhihu.com/p/42239873（详细讲解了线性一致性以及Raft协议相关知识）
  * 知乎：https://zhuanlan.zhihu.com/p/59119088（简单讲解了各一致性模型，无图）

### 一致性模型

* **所有允许的操作历史的集合**称为一致性模型。

  * 若一个程序经历了“允许操作集”中的一系列操作，那么任意一次执行都是**一致的**。

  * 若一个程序偶尔发生故障并且出现了不是“允许操作集”中的历史操作，那么历史记录就是**不一致**的。

  一致性模型本质上是**进程与数据存储的约定**：如果进程遵循某些规则，那么进程对数据的读写操作都是**可预期**的。

* 每种一致性模型都有效**限制了**（或者说**规定了**）**在对一个数据项执行读操作所应该返回的值**（如强一致性模型，就规定了读数据请求发出后，得到的一定是最后一次写操作之后的结果），而这也是区分不同一致性的因素之一。

* 因为理解一致性的角度有两种（**客户端**视角和**服务端**视角），所以可以将一致性模型分为**“以数据为中心的一致性模型”**和**“以用户为中心的一致性模型”**。

  * 以数据为中心：需要关心整体所有数据、所有进程的相关一致性
  * 以用户为中心：只需要关心某一个用户（即进程）的数据一致性，满足该用户即可

* 根据[Jepsen](https://jepsen.io/consistency)的图片，也可以将所有一致性模型分为两类：

  - **可串行化**（Serializable），又叫**事务一致性**，是一种**事务隔离的级别**，也就是ACID中的I（Isolation）。它保证**事务在并发执行时的执行顺序对数据的一致性没有影响**。可串行化并**不保证数据读写的时间顺序**，比如数据库，执行SQL语句时，我们允许数据库对其子操作的执行顺序进行任意的重排，只要最后要做的事情保持不变即可。
  - **可线性化**（Linearizable），又叫**数据一致性**，它表示**某个对象在写操作之后是否能马上读到这个最新的值**。比如，我们更新了twitter上的昵称，那刷新页面之后是不是能不能马上看到这个变化，还是说在一段时间内，刷新页面可能还会看到老的昵称？

  串行化和线性化的结合也就是严格串行化，事务行为是等同于一些串行执行，串行的顺序符合实时，举例，说我开始和提交了事务T1，这个事务写入到条目x，然后后来你开始和提交了事务T2，这是从x中读取，数据库提供严格串行化将把T1放在T2之前以串行化顺序执行，T2会读取出T1的写入结果。数据库提供的串行化（但不是严格串行化）能将T2排序在T1之前。

  ![image.png](https://int64.me/images/jepsen.png)

### 并发系统和分布式系统的联系

* 不同点：

  * 在并发系统中，读操作与写操作可能是**多线程**并发地在**不同 CPU** 上执行。

  * 在分布式系统中，它们可能是**多进程**被分布在**不同的物理节点**上执行。

* 相同点：

  * 这两类系统中的读操作与写操作都有**一定的延迟，不是瞬间完成的**。

* 所以它们都可以建立在抽象的**多读者、多写者寄存器（MWMR register, multiple writer multiple reader register）模型**之上。

### 分布式系统的实际情况

* 分布式系统通常是由**很多个节点**组成，作为一个整体对外提供服务，**每一个节点都拥有自己的数据副本**。

* 满足多读者、多写者寄存器模型：

  * 有时系统会遇到**网络异常**或者**节点故障**的情况，从而导致数据副本之间存在着或多或少的延迟，所以每一次的客户端的读、写**请求发起的时间**和**收到响应的时间**总是有段差距，不是瞬间完成的，而客户端并**不清楚系统具体何时真正处理请求的**，而只知道它是**发生在发起请求之后、收到响应之前的某一个中间点。**

  * 形象化地，每一个操作执行都有一个响应**时间段**，而真正对存储器（模型中的寄存器）进行读写改变的时刻是一个**时间点**，这个**时间点随机落在操作的时间段内**。同时，多个客户端进行的请求，其各自对应的响应时间段会出现**重叠**情况，这就会导致即使读操作和写操作发生的时间段一模一样，但也无法确定请求最终的响应结果。

    ![img](https://pic3.zhimg.com/80/v2-78a2755203d68e5ad39b1de512cef16e_720w.jpg)

# 可线性化的一致性模型（数据一致性）

### 线性一致性（Linearizability）

* 又叫**严格一致性**或**原子一致性**。

* 线性一致性的基本的想法是**“让一个系统看起来好像只有一个数据副本，而且所有的操作都是原子性的”。**

* 判断系统是否线性一致性，需要：

  * 假设将所有操作等价为**该操作时间段**内部的、具体的**读写操作时间点**，即，将所有**非瞬时**的操作**等效**为一个**瞬时完成**的读写操作，任何操作都在调用和返回之间**原子地、瞬间地**执行，并且将这些操作都线性化到一个全局时间轴上（很显然这需要维护一个**全局时钟**），各个进程的操作历史**按照严格的全局时间顺序进行排列**。
  * 若**实际的结果与在全局时钟维护下得出的结果一致**（即**实际操作历史得出的结果符合全局时钟维护下的结果**），那么该系统为线性一致的。
  * 或者说，若实际的结果在全局视角下是“**合法的**”（即**每一次读操作返回的都是上一次写操作的结果**），那么该系统满足线性一致性。

  ![img](https://static001.geekbang.org/infoq/f1/f107a622da78d2cb421492fc4a196c2b.png)

  上图中各进程的**各操作历史时间段都有重叠**，但是将各操作**“原子等效化”**、并且**线性化在全局时间轴上、按照全局时间顺序排列**后，我们发现**排列后、在全局时间维护下的结果和上方三行实际结果一致（或者说，每一次读操作的到的结果，都是上一次全局时间下最近写操作的结果）**，故而上图中对应的系统满足线性一致性。

* 很明显，要满足线性一致性必须有**两个具体要求**：

  * 系统中**所有进程**，看到的**所有操作历史顺序**都必须一致，并且都**与全局时钟下的顺序一致**（因为各进程都将全局时间作为**参考系**，都按照全局时间排列各操作历史，那么自然**各进程看到的操作历史顺序都是一致的，并且和全局时钟下的顺序一致**）。
  * 任何进程、任何一次读都能**看到某个数据的最近一次写的值**

* **形象化**地描述线性一致性就是：在全局时间轴下，有两个写操作，**无论是哪个进程，无论进程在何处，无论两次写操作之间的时间间隔有多小，**该**两个写操作之间的所有读操作得到的结果都是一致的，并且与前一次写操作的结果相同。**
* 分布式系统中实现线性一致性是**对一致性要求最高**的一致性模型，就现有技术是不可能实现的，因为它要求**所有操作都实时同步**，在系统中要**维护一个准确的全局时钟,这时凭借现有技术是做不到的**（毕竟首先通信是必然有延迟的，一旦有延迟，时钟的同步就没法做到完全一致）。
* 但线性一致性**并不局限在分布式系统**，例如多核多线程系统。

### 顺序一致性（Sequential Consistency）

* 对于所有进程的操作历史（和上文一样，将各操作视为瞬时进行），按照某种顺序（**不一定是严格的全局时间轴顺序**）进行组合排列，若**存在**着一种排列序列（全序关系）满足：

  * 该序列下的结果是”**合法的**“（即**每一次读操作返回的都是上一次写操作的结果**）
  * **各进程内的操作历史先后顺序**与**在该排列中的操作先后顺序**一致

  就说这些进程所在的分布式系统是**顺序一致性**的。

  ![img](https://static001.geekbang.org/infoq/20/20fd8c234a2cc90328d39fd6db9be568.png)

  例如上图，列出了两个进程的三个操作历史的**三种排列顺序**（一共有六种），其中**存在着`order 3`这一序列是合法的、并且`P1`进程中的两个读操作顺序和`order 3`中的两个读操作顺序一致**，那么`P1`和`P2`组成的分布式系统就是顺序一致的。但是该系统**并不是线性一致的**，因为将三个操作历史按照**全局时间**排列后，**我们发现第一个`Read`操作并没有返回上一次写的结果**，在全局时间下维护的结果**不是”合法的“**。

  ![image](https://int64.me/images/linearizability-5.png)

  同样，在上图中（a）代表的系统**满足顺序一致性但不满足线性一致性**；（b）代表的系统**满足线性一致性，自然也就满足顺序一致性**；（c）代表的系统**不满足顺序一致性，自然也就不满足线性一致性**。

* 可以看出，要想满足线性一致性或者顺序一致性，都需要对所有**操作历史**，找到一种**”合法的“操作历史序列**，使得**所有进程看到的操作历史顺序，都是该序列顺序**，而两种一致性模型对该序列的限制条件则不一样：

  * 线性一致性要求在全局时间下排列，要求**满足绝对的时间顺序**，很显然，**满足要求的序列要么只有一种、要么没有**
  * 顺序一致性要求**符合各进程内部的指令顺序（编程顺序）即可**，满足要求的序列有很多种，只要存在一种序列”合法“，那么系统就是顺序一致的。

* 更**形象化**地，在外部的观察者看来，任意**单个进程的操作顺序是确定的**，但考虑所有操作的某种全局序列关系时，一个进程的读写操作**可以被插入到其他进程的任意两个操作之间**。不同的插入方式（**而不是仅限制于按照严格时间顺序来插入**），会生成不同的全局序列，只要能保证存在一个合法的序列，则满足顺序一致性。

* 线性一致性按照**全局时钟**（可以简单理解为物理时钟）为参考系，所有进程都按照全局时钟的时间戳来区分事件的先后，那么必然所有进程看到的数据读写操作顺序一定是一样的，因为它们的参考系是一样的。而顺序一致性使用的是[**逻辑时钟**](https://link.zhihu.com/?target=https%3A//yq.aliyun.com/articles/689658%3Fspm%3Da2c4e.11155435.0.0.1eb03312KTLsJm)来作为分布式系统中的全局时钟，进而所有进程也有了一个统一的参考系对读写操作进行排序，因此**所有进程看到的数据读写操作顺序也是一样的**，只不过这种顺序不一定是全局时间的实际顺序罢了。

* **满足线性一致性一定满足顺序一致性，不满足顺序一致性一定不满足线性一致性。**

### 因果一致性（Casual Consistency）

* 因果关系定义：

  * 本地顺序：在单独进程种，事件执行的顺序即为**本地因果顺序**，本地执行的事件间存在着因果关系。
  * 异地顺序：在多个进程种，如果某一进程的读操作返回的是另一进程写操作的值，那么该写操作在顺序上一定在读操作之前，两者的顺序为**异地因果顺序**，两者存在因果关系。
  * 闭包传递：如果`a->b`，`b->c`，那么肯定也有`a->c`，即，若A是B的因，B有是C的因，那么A是C的因，A和C之间存在的因果关系。

* 由定义可以看出，若一个进程$P1$对一个变量$x$进行了**写操作**，另外一个进程$P2$对$x$进行**读操作**后又进行了依次**写操作**，那么：

  * **$P1$进程的写操作**和**$P2$进程的读操作**之间存在着因果关系
  * **$P2$的读操作和写操作**之间也存在因果关系
  * 从而**$P1$的写操作和$P2$的写操作之间也存在因果关系**（可以这么理解：$P2$先对$x$的值进行读取，然后通过计算后得出结果再次写入，**此时写入的值依赖于读出的值**，从而**进一步依赖于$P1$写入的值**。也就是说，**“$P2$写操作”这个事件要受“$P1$写操作”这个事件的影响**）

* 不存在因果关系的操作之间，它们的关系为**并发关系（Concurrent）**。

* 因果一致性应该满足两个要求：

  * 所有进程必须以**相同的顺序**看到**具有因果关系的读写操作**。
  * 不同进程可以以**不同的顺序**看到**具有并发关系的读写操作**。

  ![img](https://static001.geekbang.org/infoq/9c/9cbfd2f0f7751322401fba0189998e0a.png)

  上图中，**`P1`的写操作和`P2`的写操作之间具有因果关系**，那么系统中的所有进程都必须以**相同的顺序（即`P1`先写，然后`P2`再写的顺序）**看到这两个操作。进一步地，所有进程内的**连续读操作**都只能**允许先读到`P1`的写入值，再读到`P2`的写入值**；**不允许先读到`P2`的写入值，再读到`P1`的写入值。**所以，`P3`满足因果一致性，而`P4`不满足。

  ![img](https://static001.geekbang.org/infoq/e1/e1f25516fefe53878ca2d2694bd0dd7a.png)

  而在该图中，**`P1`的写操作和`P2`的写操作之间不存在因果关系**，所以系统中所有进程都可以以**任意顺序**看到这两个操作，所以`P3`、`P4`都满足因果一致性。

* 顺序一致性虽然不保证事件发生的顺序跟实际发生的保持一致，但是它能够保证所有进程看到的读写操作顺序是一样的。而**因果一致性更进一步弱化了顺序一致性中对读写操作顺序的约束，仅保证对有因果关系的读写操作，所有进程看到的顺序是一样的，没有因果关系的读写操作（并发事件）则不做保证。**也就是说如果是无因果关系的数据操作**不同进程看到的值是有可能是不一样**，而有因果关系的数据操作**不同进程看到的值保证是一样的**。

### 最终一致性（Eventual Consistency）

* 最终一致性是一种**以用户为中心**的一致性模型，只保证所有副本的数据**最终在某个时刻会保持一致**。也就是说，如果更新时间间隔比较长，那么所有的副本都能够最终达到一致性。
* 最终一致性是弱一致性的一种特例，在该情况下，用户读到某一操作对系统特定数据的更新需要一段时间，这段时间被称之为**“不一致窗口”**。在不发生失败的情况下，**不一致窗口的大小**将依赖于**交互延迟**、**系统负载**以及复制技术中的**副本个数**。
* **DNS**可以说是最终一致性方面最出名的系统（这就是一个典型的**读多写少**的系统），当一个域名IP被更新后，根据不同的配置策略和缓存控制策略，所有的客户最终都能查询到最新的IP地址。

# 可串行化的一致性模型（事务一致性）

### 可串行化一致性（Serializable Consistency）

* 可串行化是**事务的隔离属性**，其中每隔事务可以读写多个对象（行，文档，记录等）。它用来确保**事务的执行结果和串行执行（每次执行一个事务）的结果完全相同**，即使串行执行的顺序可能和事务的实际执行顺序不同。

# 拜占庭将军问题

### 拜占庭将军问题

* 由于硬件错误、网络拥塞、连接断开或遭到恶意攻击等原因，计算机和网络可能会出现**不可预料**的问题。而拜占庭问题则特指分布式系统中某些恶意节点扰乱系统正常运行的情况，包括**选择性不传递消息**、**选择性伪造消息**等。
* 很显然，拜占庭错误是一个**最悲观、最强**的错误模型，它**对系统的容错性要求也是最高的**。同时，这种错误在实际情况中非常**罕见**。
* 如果某个一致性协议能够保证系统在出现**N个拜占庭错误**时，**依旧可以做出一致性决定**，那么这个协议也就能够处理系统出现**N个其他任意类型**的错误（因为**拜占庭错误对系统的影响最大，处理拜占庭错误的技术要求也最强**）。

### 进程失败错误（fail-stop Failure）

* 假设当某个节点出错时，这个节点会停止运行，并且其他所有节点**都知道这个节点发生了错误**（很显然，在拜占庭问题中，某些节点会做出一些恶意的举动，**这种拜占庭错误类型的恶意节点情况是那些正常节点所不知道的**）。
* 进程失败错误是一个**最乐观、最弱**的错误模型。
* 如果某个一致性协议在系统出现**N个进程失败错误**时，都**无法保证做出一致性决定**，那么这个协议也就**无法处理系统出现N个其他任意类型的错误**（最弱的错误类型都无法解决，那么自然其余错误也无法解决）。

### 基本假设及结论

* 一个RSM系统要容忍**$N$个拜占庭错误**，至少需要**$2N+1$个复制节点**。如果只是把错误的类型缩小到**进程失败**，则至少需要$N+1$个复制节点才能容错。
* 综上所述，对于一个通用的、**具有复制状态机语义**的分布式系统，**如果要做到$N$个节点的容错，理论上最少需要$2N+1$个复制节点**。这也是典型的一致性协议都要求**半数以上$(N/2+1)$**的服务器可用才能做出一致性决定的原因。例如，在一个5节点的服务器集群中要求至少其中3个可用；如果小于3个可用，则会无法保证返回一致的结果。

# 复制状态机

### 有限自动状态机（FSM）模型

* FSM是一种数学模型，是一个**对真实世界的抽象**，而且是**逻辑严谨的数学抽象**。FSM由状态和改变这些状态的操作等一系列要素组成，随着系统的运行，它会通过一些操作历史**从一个状态转移到另一个状态**，这个过程会产生输出。

* 状态机有下面几个组成部分：

  - 一系列状态
  - 一系列输入
  - 一系列输出
  - 过渡方程
  - 输出方程
  - 开始状态

  一个状态机开始于给定的**开始状态**。每个收到的**输入**都通过**过渡方程**和**输出方程**来产生一个新的状态以及相应的**输出**。这个新的状态会一直保持到下一个输入到达，产生的输出会传递给相应的接收者。

* FSM必须具有**确定性**：若同一状态机的多个副本以**“相同的初始状态”**开始，并且以**相同顺序**接收**相同输入**，那么它们**必定**会生成**相同输出**，并且转换为**相同状态**。这同时也是对复制状态机的理解。

### 复制状态机（RSM，Replicated State Machines）

* 在分布式系统中，一组数据（或者说一个节点）往往会有多个副本，用以提供分布式服务，但多个副本就带来了不一致问题。复制状态机就是用来解决副本的一致性问题的。

* 每一个副本都是**同一个确定的、有限自动状态机的同种复制**，每一个服务器都持有这样的一个副本。这就意味着在**相同的输入和初始状态**下，每一个服务器副本都能**进行相同的状态转换并且提供相同的输出**。

* 一般通过使用复制**日志**来实现复制状态机：

  * 每个 `Server` 存储着一份**包含命令序列的日志文件**，状态机会**按顺序**执行这些命令。
  * 若每个日志**包含相同的命令，并且顺序也相同**，那么每个状态机将会**处理相同的命令序列**。
  * 进一步地，由于状态机是确定性的，所以各状态机处理完毕后**会转换为相同的状态，并且得到相同的输出。**

  ![img](https://knowledge-sharing.gitbooks.io/raft/content/assets/Figure-1-Replicated-state-machine-architecture.png)

  这样，**保证系统一致性**的任务就转换为**保证每个服务器上的操作日志一致性**的任务。而**一致性算法**的主要工作就是确保操作日志的一致性。

* 每一个 `Server` 上的**一致性模块**会接收来自客户端的命令，并把命令添加到它的日志文件中。它**同其它 `Server` 上的一致性模块进行通信**，确保**每一个日志最终包含相同的请求且顺序也相同**，即使某些 `Server` 故障。一旦这些命令被正确复制，每个 `Server` 的状态机都会按照日志中的顺序去处理，将输出结果返回给客户端。最终，这些 `Server` 看起来就像一个单独的、高可靠的状态机。

* 需要注意的是，**指令在状态机上的执行顺序**并不一定等同于**指令的发出顺序或接收顺序**。复制状态机**只是保证所有的状态机都以相同的顺序执行这些命令**。基于复制状态机模型实现的主-备系统中，如果主机发生了故障，那么理论上备机有权以任意顺序执行未提交到操作日志的指令，但实际实现中一般不会这么做。


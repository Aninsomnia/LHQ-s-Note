# 操作系统的四大主要功能

* 处理机管理

* 文件管理

* 存储器（内存）管理

* 设备管理

# 用户与计算机硬件系统间的接口

* 命令接口：组织和控制作业的执行
  * **联机命令接口**：又称**交互式命令接口**，用户输入一条指令，OS解释并执行指令，执行完毕后将控制权又移交给用户。**主要适用于分时或者实时系统**。
  * **脱机命令接口**：又称**批处理命令接口**，**由一组作业控制命令组成**。用户提前用作业控制命令写出一份作业操作说明书，连同作业一起提交给系统。系统调度到该作业时，**逐条解释执行命令**。**主要适用于批处理系统**。
* 程序接口：请求操作系统为用户服务
  * 又称**系统调用**，用户通过在程序中使用这些系统调用来请求操作系统为其提供服务。
* 简而言之：操作系统对上层的接口有两种：
  * 一个**面向用户：即命令接口**
  * 一个**面向上层程序（或者程序员）：即系统调用**

# 操作系统的四大特征

* **并发**：指两个或多个事件在**同一时间段内**发生，而并行是指两个或多个事件在同一时刻发生。并发的多个事件**宏观上同时发生**，但在**微观上是不同时刻交替发生的**。
* **共享**：指系统中资源**可供内存中的多个并发执行程序共同使用**。
  * **互斥共享**：指某个资源只允许一个进程访问该资源，**其他进程想要访问该资源必须等待当前进程访问完毕且释放该资源后**，才可进行。例如打印机、磁带机等。
  * **同时共享**：指某些资源**可以在一段时间内被多个并发进程并发地访问**，通常宏观上看它们是同时访问的，但在微观上，这些进程可能是**交替地对资源进行访问，即“分时共享”**。
  * 注意：互斥要求资源在一段时间内**只能满足一个要求**，而同时访问通常**要求访问请求分几个时间片段，间隔地完成**，其完成效果**与连续完成效果相同**。
  * **并发和共享互为存在条件**：①若只有共享，没有并发，那么**共享就没有存在的意义，自然也不存在资源共享问题。**②若没有共享，那么**必然会影响程序的并发执行，甚至根本无法并发执行**。

# 操作系统的发展与分类

* **手工操作阶段**：用户独占全机，CPU等待手工操作，利用不充分。
* **批处理系统**：
  * **单道批处理系统**：成批地处理作业，但内存中始终保持一道作业。
  * **多道批处理系统**：允许**多个程序**同时进入内存并且**交替**地运行。这意味着这些程序要**并发**执行，并且还要**共享**系统资源。**这便需要操作系统进行分配和调度**。
  * 多道批处理系统并不采用某些机制让某一技术效率提高，而是**让系统地各个组成部分尽可能的“忙”起来**（例如当一道程序因I/O请求而暂停运行时，CPU便转而去运行其他程序，不必在原地等待该I/O操作完成）。
* **分时操作系统**：**把处理器的时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用**。
* **实时操作系统**

# 操作系统的相关运行机制

### 特权指令与非特权指令

* **特权指令**：只允许内核执行的指令，不允许用户直接使用的指令（如I/O指令、置中断指令）。
* **非特权指令**：用户可以直接使用的指令。

### 内核态和用户态

* CPU为**内核态（管态、核心态**）时，**CPU可以执行特权指令，操作系统内核程序就运行在内核态**。
* CPU为**用户态（目态）**时，**只能执行非特权指令，用户自编程序就运行在用户态**。
* 使用**程序标志寄存器（PSW）中的某一位**来识别当前CPU是处于核心态还是用户态。

### 内核

* 内核是计算机中**最底层的软件，是操作系统最基本、最核心的部分。**
* 大多数OS的内核都包括以下内容：
  * **时钟管理**
  * **中断机制**
  * **原语**
  * **对计算机资源的管理**：进程管理、存储器管理、设备管理。
* 当内核都包含这四点时，该内核为**大内核**；某些只包含前三点的内核，叫**微内核**。
  * 大内核：将OS主要功能模块都作为内核，性能高。但是内核庞大，难以维护。
  * 微内核：只将最基本的功能作为内核，结构清晰、方便维护。但是会出现**频繁在内核态和用户态之间切换的状况，性能低**。

### 中断

* **中断（Interrupt）**是一种信号，用于**通知CPU需要立即停止当前执行的任务并处理紧急事件**。
* 操作系统不断的发展过程就是想方设法不断提高资源利用率的过程，而想要**提高资源利用率**，**就必须在程序并未使用某些资源时，通过某种方式，把它对那种资源的占有权释放出来**。
* 系统不允许用户程序实现核心态功能，但它们又必须使用这些功能，所以**必须通过中断来让CPU从用户态转变为核心态**。
* 当出现中断时，就表明**计算机出现了某些状况，需要操作系统介入进行处理**，而操作系统的介入处理（例如进程切换、分配I/O设备）**都需要执行特权指令**，所以此时**必须将CPU转为核心态，操作系统才能正常工作**。
* **用户态转为核心态必须通过中断实现，而核心态转为用户态只需修改程序状态寄存器（PSW）的某一位就可以了**（因为修改PSW的指令是特权指令，而此时已经是核心态，可以直接执行特权指令）。
* 中断分为内中断和外中断两种：

  * **内中断**（异常、陷入、例外）：**中断的来源来自于CPU内部的事件，与当前执行的指令有关**。
    * **自愿中断**：就是指令中断，当前指令需要**系统调用**时产生的中断。
    * **强迫中断**：
      * 硬件故障：例如缺页中断
      * 软件中断：例如整数除0中断
  * **外中断**（中断）：**中断的来源来自于CPU外部的事件，与当前执行的指令无关**。
    * I/O请求
    * 人工干预
    * 时间片轮转
  
* 一般外中断处理流程

  * CPU每执行完一条指令后，都会**检查有无外部中断信号**。
  * 收到中断信号后，判断**是否屏蔽该次中断**。
  * 中断信号进行优先级排队
  * 关中断（这是**为了在保护现场时不被其他中断请求打断，此时不应该响应任何的中断请求**）
  * 保存断点，即保存**当前程序的程序计数器PC**的值
  * 查询中断表，进行中断服务程序寻址，将其送入PC，**此时开始执行中断服务程序**
  * 保存现场和屏蔽字，即保存PSW、以及其他寄存器的值
  * 开中断（此时开中断表明，**保存现场的工作已经完成，可以在执行中断服务程序时，接受其他更高级别中断的请求了**）
  * 执行中断服务程序
  * 关中断（同样，**此时关中断是为了在恢复现场和屏蔽字时不被打断**）
  * 恢复现场和屏蔽字
  * 开中断，表明恢复现场已经完毕
  * 中断返回，返回原程序的断点处


* 一般来说，是**硬件中断机制**将处理机置为核心态。
* 注意：最开始的关中断**是为了在保存现场时不被干扰**；然后开中断表明**保存现场已经完毕，允许在执行中断服务程序时接受更高级的中断请求**；然后关中断同样是为了**在恢复现场时不被干扰**，最后开中断则表明**恢复现场以及整个中断服务程序执行完毕，可以接受其他中断请求了**。
* 中断向量统一放在中断向量表中，由**OS**初始化。

### 系统调用

* 系统调用是OS**面向应用程序或者程序员**的程序接口。
* 在计算机中，**所有的资源都由OS进行统一的管理和调度，不允许用户程序直接使用、分配那些资源**。当用户程序想要使用、分配那些资源时，**必须通过系统调用的方式向OS提出服务请求，让OS统一地代为完成**。这样可以**保证系统的稳定性和安全性，防止各个用户程序混乱地使用计算机资源**。
* 系统调用按功能分类：
  * 设备管理
  * 文件管理
  * 进程管理
  * 进程通信
  * 内存管理
* 可以看见，系统调用相关的操作**涉及资源管理、进程管理**之类的命令，这些操作对整个计算机影响巨大，因此**必定会执行某些特权指令**，所以**系统调用的处理一定要由OS内核来执行，而且一定是在核心态下完成的**。但是对系统调用的**“调用”可能发生在用户态**。

* 系统调用和库函数的区别：

  * **OS内核会向上层提供一些系统调用**，这些系统调用**屏蔽掉了计算机硬件的某些细节**。

  * **高级编程语言将这些系统调用封装成库函数**，其中也很会**屏蔽掉一些OS的细节**，向用户程序提供，这样上层使用系统调用就会更加方便。

  * 用户程序直接使用库函数，就相当于向OS发出了系统调用的请求。

  * 注意：只有当库函数的功能涉及资源使用、资源管理、进程管理相关的内容时，库函数才会涉及系统调用。


* 系统调用的背后过程
  * 程序代码中调用的库函数，在编译后，**会被编译出一条`int x`的陷入指令（又称trap指令、访管指令，int的意思是“interrupt”）**

  * 用户程序**在用户态下执行该陷入指令，发起系统调用**

  * 随即发出一个**内中断信号**

  * CPU响应中断信号，此时**CPU进入核心态，操作权交给了OS内核**

  * OS内核执行该系统调用的相关操作
* 可以看出：陷入指令的作用是**在用户态下，发出内中断信号，进而使得CPU进入核心态**。这表明**陷入指令只能在用户态下执行，不能在核心态下执行，不可能是特权指令。这也是唯一一个只能在用户态下执行，不能在核心态下执行的指令**（因为能在用户态下执行的非特权指令，一般都能在核心态下执行）。

#  OS的四大主要功能之一：进程管理（处理机管理）

### 进程的相关概念

* 每个程序都有各自的**程序段**和**数据段**，为了区分这些程序段和数据段属于哪一个程序并且为了它们拥有**并发**和**共享**的特性，**必须为之配置一个专门的数据结构，该数据结构就是进程控制块（PCB）**。
* 在PCB中，保存着**用于描述进程基本情况、运行状态等的基本信息，进而控制进程和管理进程**。
* 由**程序段、数据段和PCB**三部分组成的就是一个进程的**进程映像（进程实体）**。
  * 注意：**只有程序段和数据段不能叫做进程映像**，此时必须通过创建PCB，才能创建一个进程；
  * 所以：**创建进程，实质上就是创建PCB；撤销进程，实质上就是撤销PCB**。

* 综上，我们可以这样定义一个进程：进程是**一个程序及其数据在计算机中运行的一个过程，是进程实体的运行过程**。
* 计算机中的“系统资源”指的是CPU、存储器以及其他设备服务于某个进程的**“时间”**。例如：“**将CPU资源分配给某个进程**”，应当被理解为“**将CPU的时间片分配给某个进程**”，因为进程获得的不是这些资源，而是**这些资源的“使用权”和“使用时间”**，这也就决定了**进程一定是一个动态的、过程性的概念**。

### 进程实体的组成

* **PCB**：
  * **进程描述信息**：
    * **进程标识符（PID）**：用于唯一区别每个进程
    * **用户标识符（UID）**：用于区别进程所属的用户
  * **进程控制和管理信息**：
    * **进程当前状态**：处理机分配调度的依据
    * **进程优先级**：进程抢占处理机的优先级
  * **资源分配清单**：分配给该进程的所有系统资源
  * **处理机相关信息**：在进程被切换时，需要保存相应现场和屏蔽字，这些内容保存的位置就是该进程的PCB中
* **程序段**：保存着可被CPU执行的二进制代码段。程序段可以被多个进程共享。
* **数据段**：该进程的相关数据

### 进程的组织

* OS组织进程不必将每一个进程实体作为组织单位，同时因为OS识别进程的唯一方法是识别PCB，那么**组织不同进程完全可以通过组织不同进程的PCB来完成**。
* **链接方式**：按照**进程状态，将同一种状态的PCB链接为一个队列**，其中也可以按照**阻塞进程的不同阻塞原因，排成多个阻塞队列**。OS持有各个队列的指针。
* **索引方式**：按照**进程状态**，**将同一状态的进程组织在一个索引表内，索引表项指向相应的PCB**。

### 进程的特征

* **动态性**：进程最基本的特征
* **并发性**：内存中同时存在多个进程实体，能在一段时间内同时、交替运行
* **独立性**：进程是能**独立运行，独立获得资源和独立接受调度的基本单位**
* **异步性**：进程按照**各自独立的、不可预知的速度**向前推进。异步性会导致结果的**不确定性**和**不可再现性**，所以要在OS中引入相应的**进程同步机制**。
* **结构性**：进程实体总是由PCB、数据段和程序段构成
* 注意：进程若有封闭性，则**无论运行速度如何、运行顺序如何，结果都是一样的**，其结果只取决与该进程本身。

### 进程的状态及其互相转换

* 进程的五种状态，其中前三项为**三种基本状态**：
  * **运行态**：进程正在CPU上运行；
  * **就绪态**：进程**获得了除CPU之外的一切资源**，一旦得到CPU的使用权限，便可立即运行；
  * **阻塞态**：进程正在**通过系统调用请求OS服务或者等待某一事件的发生而暂停运行**，例如等待OS分配内存，或者等待I/O设备执行结果；
  * **创建态**：进程**正在被创建**，尚未转为就绪态。此时一般会有如下工作：
    * OS申请一个空白的PCB；
    * 向PCB中填入一些控制和管理信息；
    * OS为该进程分配相关的资源
  * **终止态**：进程正在被OS撤销、回收
* 区分就绪态和阻塞态：
  * 如果进程调度的依据之一是CPU时间片的轮转，那么**每一个进程获得CPU的使用权时间很短，CPU切换进程也很频繁，所以进程在运行态和就绪态之间的切换也很频繁**。
  * 而其他资源的分配或者某一事件的发生所对应的时间较长，那么**进程处于阻塞态的时间也会较长，在运行态和阻塞态间切换的频率也比较低**。
  * 所以就绪态和阻塞态不仅仅是未获得的资源类型不同，两者更是完全不同的两种状态，显然需要加以区分。
* 进程状态的转换：
  * **就绪态**转换为**运行态**：进程获得了CPU资源（CPU时间片），开始运行
  * **运行态**转换为**就绪态**：进程运行过程中，由于**分配的时间片用完，或者有更高级的进程前来抢占CPU使用权**时，不得不让出CPU使用权，转换为就绪态
  * **运行态**转换为**阻塞态**：进程通过**系统调用**请求**某一资源**或者等待**某一事件**的发生，从而停止运行，转换为阻塞态，进行等待
  * **阻塞态**转换为**就绪态**：等待的资源被分配给该进程，或者等待的事件发生，该进程由阻塞态转换为就绪态，等待CPU资源的分配
* 值得注意的是：
  * 进程在运行态时，**通过系统调用的方式请求OS提供服务**，使得自身进入阻塞态。这说明，进程从运行态转换为阻塞态是一个**主动**的过程。
  * 而进程在阻塞态时，根本就不处于运行的状态，所以从阻塞态转换为就绪态是一个**被动**的过程。

### 进程的控制

* 一般将进程控制相关的操作称为**原语**，原语在执行过程中不允许中断，是一个不可分割的基本操作单位，这个过程是由**开/关中断**实现的。
* 进程控制的主要功能主要包括：
  * **创建新进程**：一个父进程创建子进程，子进程可以**继承所有父进程拥有的资源**。OS创建一个进程所执行的**创建原语**内容如下：
    * 申请空白PCB，分配唯一的PID
    * 初始化PCB，填入相关管理和控制信息
    * 分配所需的相关资源
    * 插入就绪队列
  * **进程的终止**：①正常结束；②异常结束；③外界干预。若被终止的进程还有子孙进程，**应将所有子孙进程终止**，并且将该进程拥有的所有资源，**归还给父进程或者OS**。
  * **进程的阻塞和唤醒**：
    * 进程自己执行**Block原语**，使自己变为阻塞态；
    * 其他进程执行**Wakeup原语**，使之前那个被阻塞进程唤醒。
    * Block原语和Wakeup原语要成对使用。

### 进程切换与处理机模式切换

* 进程切换的过程会涉及很多特权指令，**必须在OS内核的调度下才能进行**，所以进程切换前，**必须进行处理机模式切换（中断），将模式切换为内核态。**故而在用户态不会发生进程的切换等行为，**用户态中的进程只有运行态一种状态**。
* 而处理机模式切换，**不一定会引起进程状态的改变，进而也不一定导致进程切换**。（例如：一个进程从用户态运行切换为核心态运行；一个进程运行时，CPU突然因为中断请求或者异常进入核心态模式，执行完毕后又回到用户态**刚被中断的进程**继续运行。这两个过程中模式发生了模式切换，但进程和进程状态都未被切换）。**模式切换频率高，进程切换频率低。**

### 进程通信

* **共享内存（共享内存）：多个进程共享一个给定的内存区**，在对共享空间进行读/写操作时，需要使用**同步互斥工具**（如**PV操作**），对其进行控制。
  * 低级的基于数据结构的共享
  * 高级的基于存储区的共享
* 信号量：可以看作一种计数器，用于实现进程间的互斥和同步，但不能用于存储进程间的通信数据。
* **管道通信**：一种连接读进程和写进程的**共享文件**通信方式。速度慢，容量有限。
  * 当写进程往管道内**写数据时，读进程不允许读数据**，直到管道**写满数据后，写进程的write()调用被阻塞**，此时读进程便可开始从管道内读数据。
  * 当读进程从管道内**读数据时，写进程不允许写数据**，直到管道全部被读取，**管道变为空时，读进程的read()调用被阻塞**，此时写进程便可开始往管道内写数据。
  * 所以进程对一个管道的访问是**互斥**的，并且**没写满就不允许读，没读空就不允许写**，故而管道只能采用**半双工通信**的方式进行传输数据。
  * 因为管道内数据**被读取后就会被丢弃**，所以**只允许存在一个读进程**。
* FIFO（命名管道）：任何进程都能通讯，但是速度慢。
* **消息传递**：进程间的信息以**格式化消息为单位**进行传递。
  * 直接通信方式：发送进程直接将消息发送给接收进程，并将它挂在接收进程的**消息缓冲队列**上。
  * 间接通信方式：发送进程将消息发送到某个**中间实体**，一般称为“信箱”
* socket：套接字也是一种进程通信，用于不同主机上的进程通信。

### 线程的相关概念

* 引入线程是为了**减小程序在并发执行时所付出的时空开销，提高系统的并发性能**
* 线程可以看为“轻量级进程”，是**基本的CPU执行单元，也是程序执行流的最小单元，是被系统独立调度和分派的最小单元**。
* 进程作为获得系统资源的最小单元，其中的多个线程可以共享该进程所拥有的所有资源。
* 一个线程**可以创建和撤销另一个线程**，多个线程间可以并发执行。由此，线程也有自己的**三种基本状态：运行、就绪和阻塞**。

### 进程与线程的区别与联系

* **定义：**
  * **进程是程序在操作系统中的一次执行过程；**
  
  * **线程是进程中的一个执行实体，是最小执行单元。**
* **调度和拥有资源**：
  * 进程拥有自己独立的地址空间（包括PCB、程序段和数据段），是**拥有资源的基本单位**；
  * 线程只会占用一点必不可少的资源，是**独立调度的基本单位**。
  * 进程内多个线程可以**共享该进程的系统资源（例如文件、信号、数据内存、甚至部分代码）**，若线程也是拥有资源的单位，那么线程和进程概念上就没有区别。
  
* **系统开销**：
  * 在切换进程时，会将整个上下文环境进行保存和恢复，开销巨大；
  * 在切换线程时，只需要保存和设置少量寄存器内容；
* **通信**：
  * **同一进程内部的线程间的通信和同步**非常容易，**甚至无须操作系统干预**（例如直接读取进程的数据段、全部变量等）；
  * 而进程间的通信则需要**进程同步和互斥手段**来辅助。
* 为什么引入线程会提高系统的并发性：可以这样理解，因为有了线程，那么**在线程切换时，可能会发生进程切换，也可能不会发生进程切换**，那么平均而言，每次线程切换的开销就比进程切换时的开销要小了。

### 线程的分类

* **用户级线程（ULT）**：
  * **线程的管理都由用户应用程序在用户态执行，内核并不能意识到线程的存在**；
  * 用户程序可以在用户态使用**线程库**来创建、撤销线程，同样**对这些线程进行切换也无需内核的干预**；

* **内核级线程（KLT）**：
  * **线程的所有管理都由内核来进行，应用程序并没有进行线程管理的代码，只有一个到内核级线程的接口**；
  * 线程在切换时，需要**操作系统进入核心态**干预。

* 二者组合的使用方式：**将多个用户级线程映射到一些数目小于或等于的内核级线程上**：
  * 内核只能识别到内核级线程的存在，所以**OS内核调度的基本单位是内核级线程而不是用户级线程**。
  * 用户级线程调度是在用户态下完成的，**不涉及内核态与用户态之间的频繁切换**，内存的分配和释放都是**通过在用户态维护着一块大的内存池来实现**，不直接调用系统的malloc函数（除非内存池需要改变），成本比调度内核级线程低很多。


### 多线程模型

* **多对一模型**：一个进程中的**多个用户级进程只映射到一个内核级进程上**。
  * 优点：各个线程的管理都在用户态完成，效率高。
  * 缺点：**并发度不高，且只要有一个用户级线程阻塞，那么它们所映射的那个内核级线程也会被阻塞，从而导致整个进程被阻塞**。
* **一对一模型**：一个进程中的**每一个用户级线程都映射到各自的一个内核级线程上**。
  * 优点：当一个线程阻塞后，不影响其他线程和整个进程的执行。
  * 缺点：此时线程的管理都是由内核完成，此时CPU要切换到内核态，并且线程数量较多，整体开销较大。
* **多对多模型**：即将$n$个用户级线程映射到$m$个内核级线程上（$n > m$）。
  * 特点：并发性较高，且由于映射了多个内核级线程，不必频繁触发OS内核调度，只需在用户态进行用户级线程调度即可。

### 调度类型

* **高级调度（作业调度）**：
  * 从外存的后备队列中选择合适的作业调入内存，给它们分配内存、创建PCB，使其成为一个进程；

  * 每一个作业只被调入一次、调出一次；

  * 发生的频率最低。

* **中级调度（内存调度）**：
  * 将内存中暂时不能运行的进程的进程调至外存，使其成为**挂起态**，将空闲内存空间留给需要的进程使用；

  * 将外存中的挂起态进程调至内存，使其成为就绪态；

  * 一个进程可以被多次调入调出，发生的频率中等。

* **低级调度（进程调度）**：
  * 即从就绪队列中选出一个进程，使其获得处理机使用权限。
  * 这是一种最基本的调度，发生的频率最高。



* 调度的时机、切换与过程：

  * 进程在访问**内核临界资源**时，不允许进行进程调度。这是因为内核中的临界资源一般都是某些**内核数据结构**，如果此时还要进行进程调度，**使得进程一直占用内核临界资源，将极有可能影响到操作系统内核的其他管理工作**。

  * 进程在访问**用户态临界资源**时，**占用用户空间临界资源不会影响到内核的管理工作**，所以此时允许进行进程调度和切换。


### 调度算法

* 追求**公平**的**先来先服务（FCFS）**：根据进程（作业）进入就绪队列的时间，选择**最先进入队列**的那个进程（作业），对其进行调度
  * **对长进程（作业）有利，对短进程（作业）不利**（因为会导致**某个长作业后面的许多短作业等待很长时间**，使得它们的**周转时间**和**带权周转时间**都很长）。
  * 本质上就是**谁的等待时间最长，选择谁进行调度**。
  * FCFS属于**非抢占式算法**，只有在**任务完成**或者**主动阻塞**时才会释放处理机使用权。所以**不能作为分时系统和实时系统的主要调度策略**。
* 追求**更少平均等待时间、更少平均周转时间和更少平均带权周转时间**的**短作业优先（SJF）**：
  * 对长进程（作业）不利，**甚至会出现“饥饿”的现象**。
  * 默认是非抢占式，对应的抢占式算法为**“最短剩余时间优先（SRTN）”**算法，**该算法的平均等待、平均周转等指标比非抢占式的SJF的对应指标还要优秀**。
* 追求折中的**高响应比优先（HRRN）**算法：
  * **$响应比 = (等待时间+要求服务时间)/ (要求服务时间)$**
  * **等待时间相同时，要求服务时间越短的，响应比越高**，有利于短作业（SJF）。
  * **要求服务时间相同时，等待时间越长，响应比越高**，此时变为了先来先服务（FCFS）。
  * **而长作业的响应比，可以随着时间的增长动态地增加**，克服了“饥饿”问题，兼顾了长作业。
  * 需要对要求服务时间进行估计。
* FCFS、SJF以及HRRN算法**完全不关心任务的“响应时间”和任务的紧迫性**，所以不会直接使用在分时或实时系统中。
* 更注重“响应时间”的**时间片轮转（RR）**算法：
  * RR是抢占式的算法，这通过**时钟中断**实现
  * 当时间片**很长**时，**大部分甚至全部的进程都能在一个时间片内执行完毕**，此时算法退化成**先来先服务（FCFS）**。
  * 当时间片**很短**时，CPU处理机将会**不停地发生进程切换**，这会导致系统开销变得很大，而**真正用于运行进程的时间将会很少**。
  * 该算法仍然**不区分任务的紧急程度**，因为不论任务的紧迫性如何，都必须公平地获取时间片进行轮转。
* 优先级调度算法：
  * **FCFS**实质上就是将**等待时间长短**看作优先级。
  * **SJF**实质上就是将**运行时间长短**看作优先级。
  * **HRRN**实质上就是将**响应比：(等待时间+要求服务时间)/ (要求服务时间)**看作优先级，并且响应比还是一种**动态变化的优先级**。
  * **I/O型密集进程的优先级要大于计算型密集进程**，这是因为I/O设备的运行速度要远远慢于处理机，若让那些I/O型进程尽早开始工作，那么**处理机和I/O设备就可以尽可能地并发工作，系统的整体效率就会尽可能的高**。
* 完美的、集大成的**多级反馈队列调度**算法：
  * 队列从第$1$级到第$n$级，**优先级不断降低**。
  * 除了第$n$级队列完全采用时间片轮转（RR）算法进行调度外，**其余的所有队列都采用FCFS的原则、RR的方法**来进行调度（即先来先服务，但是只服务一个时间片，这唯一一个时间片用完后，该进程将会被放入下一级队列中），且**时间片长度随优先级的降低不断翻倍**。
  * 新进程会被放入第1级队列中，也就是优先级最高的队列。
  * **任何时刻**，处理机执行的永远都是**优先级最高的那个进程**。注意是**任何时刻**，所以当一个低优先级队列中的某个进程正在被执行，此时一个新的进程进入了第$1$级队列，那么**新进程将会抢占正在运行进程的处理机**。
  * 该算法集成上文几个调度算法各自的优点：
    * 各类进程相对公平，先来的进程一定会先被服务（FCFS的优点）
    * 因第$1$级队列时间片最小，那么**新进程一定会在很快的时间内被响应**（RR的优点）
    * 整体来看，**短进程会以较快的速度被执行完毕**，并且也**不必事先估计进程的预计运行时间**（SJF的优点）
    * 对于长作业开来，在前几个优先级队列中**已经得到了部分执行，不会出现长期完全得不到执行的情况**。
    * 但是会有**“饥饿”**的情况发生。

### 进程的异步性

* 进程**不会意识到其他进程的存在，并且也不会受到其他进程的直接影响**，在进程的眼中，只有计算机的相关资源，**得到了资源就可以执行，得不到就只能等待**“，而多个进程则会对资源进行竞争。
* 所以在不加人为干预的情况下，**任何进程间都存在着“竞争关系”或者说“间接的制约关系”**。
* 这会导致各进程具有**执行上的间断性，各自按照独立的、不可预知的速度向前推进**，这便是进程的重要特征：**异步性**。

### 进程互斥与同步

* **互斥：**

  * **为了解决进程的“间接的制约关系”或者“竞争关系”**，就必须实现**进程互斥**，当一个进程使用某种临界资源时，其余进程必须等待。

  * 对临界资源的访问代码的组成有：
    * 进入区：访问临界资源前，**检查是否可以访问资源、设置相关标志的代码区**。
    * 临界区：**实际访问临界资源**的代码区。
    * 退出区：**撤销相关标志**的代码区。

  * 通常，**临界区负责访问临界资源**，而**进入区和退出区负责实现进程互斥**。


* **同步：**

  * 异步性带来的最大问题就是：当**一个任务需要两个或多个进程合作完成**时，进程间就存在着一种**“直接的制约关系”**，若不能很好地处理各个进程间的工作次序，该任务的完成将会变得非常困难，或者多次完成该任务得到的结果不一致。这样，进程间的**“竞争关系”**就变为了**“协作关系”**，这**源自于它们之间的相互合作**。

  * 所以需要在OS中配备相应的**进程同步机制**，使得同一任务被多次运行，**每一次都会得到成功执行，并且都会获得相同的结果**。


### 实现进程互斥的软件方法

* **单标志法**：两个进程**必须交替**进入临界区，但如果某个进程拥有进入临界区的权限，但没有进入临界区的请求，这会导致另外一个进程即使发出进入临界区请求，也永远无法顺利进入临界区，**这违背了“空闲让进”原则**。
* **双标志先检查法**：因为**“检查”和“上锁”两个操作不是一气呵成、一次性完成的**，所以可能会出现两个进程同时进入临界区的情况，**这违背了“忙则等待”原则**。
* **双标志后检查法**：由于该算法先设置标志位，若两进程同时设置自己的标志为true，然后各自判断对方是否为true，结果**两者“互相谦让”**，结果谁也进入不了临界区，导致“饥饿”现象，**这违背了“空闲让进”和“有限等待”原则**。
* **Peterson算法**：两个进程的flag标志可能同时为true，但是系统中表明**优先**让谁进入临界区**turn的值只有可能为两个进程中的一个**，所以，无论如何，都会有一个进程可以进入临界区。因为两者“互相谦让”的条件是**“两者标志都为true，并且系统都想让两者进入临界区”**，而这个条件是不可能实现的。

### 实现进程互斥的硬件方法

* **中断屏蔽**：当一个进程在使用处理机执行临界区代码时，**禁止一切中断发生**就可以**阻止任何的进程切换**，从而**阻止任何其余进程进入临界区**（这是因为：若其他**进程想要进入临界区**，必须先进行**进程切换**，将处理机使用权切换到那个进程，而进程切换先必须先**将处理机切换到核心态**，而切换到核心态的唯一方式就是**引起中断**，故而，屏蔽一切中断就可以避免处理机切换到核心态，从而避免引起进程切换，从而避免其余进程进入临界区）。
* **注意！！！！！！！！！！！！！**
  * 进程切换前一定会中断，但**不是所有中断都是为了进程切换**，故而这种方式会极大的**影响整个系统的稳定性**，并且会**限制处理机交替执行程序的能力**。
  * 将关中断的权力交给用户是很不明智的！！！
* **硬件指令方法**：
  * **TestAndSet（TestAndSetBlock、TSL）**：
    * 和双标志后检查法相同，**先直接锁死标志，再判断标志**。不过TSL不允许被中断，是个**硬件原语操作**。
  * **Swap**：
    * 和TSL相同

### 锁

* **互斥锁与读写锁**：
  * **互斥锁**：最常规的一种锁的实现，线程在持有互斥锁对资源进行访问时，不允许其他线程访问该资源，该线程独占该锁。
  * **读写锁**：管理一个写锁和多个读锁，写锁是独占的，读锁是共享的。
    * 当一个线程持有写锁对资源进行写操作时，**不允许其他线程进行任何读写操作**；
    * 当一个线程持有读锁对资源进行读操作时，**允许其他线程进行读操作**；
    * 读锁优先级高于写锁，即**读写锁是一种非公平锁**。
* **公平锁与非公平锁**：
  * **公平锁**：获取锁的顺序**由申请锁的顺序决定**，遵循先到先得原则。
    * 除非有公平性需求，不建议使用公平锁，因为会带来性能开销。
  * **非公平锁**：获取锁的顺序**不是由申请锁的顺序决定**。
    * 这可能会导致**优先级翻转**，在高并发的场景下，甚至导致**饥饿**发生。

* **共享锁与独占锁**：
  * **独占锁**：线程占有独占锁后，该锁不能被其他线程占用。
  * **共享锁**：线程占有共享锁后，其他线程依旧可以占用该共享锁。
    * 这意味着临界资源允许被多个线程同时访问；
    * 一个线程对资源加上共享锁后，**其他线程对该资源也只能加共享锁，不能加独占锁**；
    * 线程持有共享锁后，**只能对资源进行读操作**，若想进行写操作，必须申请独占锁。

* **乐观锁与悲观锁**：
  * **乐观锁**：对于并发操作的线程安全问题**持乐观态度**，认为竞争**不总是会发生**，因此它不需要持有锁，
    * 读操作时假设数据不会被其他线程修改，写操作时判断当前数据是否被修改过，来判断竞争是否发生。通常使用**版本号机制和CAS手段**来实现乐观锁。
    * 适用于**读多写少（冲突比较小）**场景；
    * 由于线程会不停**循环**，且写失败时会触发**等待-重试**机制，当写操作比较多时，整体性能开销比较大。
  * **悲观锁**：对于并发操作产生的线程安全问题**持悲观态度**，认为竞争**总是会发生**，因此每次对资源进行操作时，都会持有一个独占的锁。
    * 适用于**写比较多**的场景；
    * 无论是读还是写都会进行锁的竞争，所以性能较低。
* **可重入锁与自旋锁**：
  * **可重入锁**：一个线程占有一个锁后，可以再次占有该锁。
  * **自旋锁**：一个线程在申请锁时，若锁被其他线程占有，那么会进入循环等待，直到成功获取锁。
    * 自旋锁的目的是**为了让线程进入忙等待，防止被挂起，减少由挂起和唤醒带来的资源消耗。**


### 信号量

* **整型信号量**：
  * 含义为**”某一临界资源的数量“**。
  
  * 和**双标志先检查法类似，先检查，再上锁**，只是使用了原语来实现检查和上锁的步骤。在wait()原语中，只要$S<=0$，就会不断地进行while循环，从而使进程处于**“忙等”**状态，这违反了**“让权等待”**的原则。
  
* **记录型信号量**：
  
  * $S.value$为负时，**负的值，就是阻塞队列上进程的个数，就是因为该信号量而阻塞的进程个数**。
  * $S.value$为正时，**正的值就是该资源空闲的个数**。
  * 和**双标志后检查法类似，先上锁，再检查**，若发现上完锁之后，**$S.value$为负**，则表明**该次请求资源失败**，将自己放在阻塞队列，并且自我block()阻塞。
  * 所以在wait()原语中`S.value--`**占用**资源之后，要**判断其是否小于0**，从而判断**当前进程是否会因资源不足而阻塞**。
  * 在signal()原语中`S.value++`**释放**资源之后，要**判断其是否小于等于0**，从而判断**之前是否有其他进程因为资源不足而阻塞**，如果有，则**将那个进程唤醒，使那个进程可以获得当前进程空闲下来的资源**（其实这时也可以**判断队列是否为空**，不为空就说明之前有进程因为资源不足而阻塞）。
  
* 使用信号量实现**互斥**：信号量初始化为1
  * **在使用资源前，P一次（wait一次、表明占用资源）**
  * **在释放资源后，V一次（signal一次、表明释放资源）**
  
* 使用信号量实现**同步**：信号量初始化为0
  * **在前驱操作后，V一次（表明前驱操作完成）**
  * **在后继操作前，P一次（表明只有在信号量为1时，即前去操作完成后才能开始后继操作）**

### 经典同步问题

* 生产者-消费者问题：
  * **对同步信号量的P操作一定要在互斥信号量的P操作之前，即先对P(empty)，再P(mutex)**，不然若先对互斥资源上锁，又得不到同步资源，那么就会陷入死锁状态。
  * 但是两种信号量的V操作先后顺序无所谓。
  * **若缓冲区大小为1，可以不用设置互斥信号量，**此时同步信号量已经起到了互斥信号量的作用。

### 死锁

* 多线程场景下，由于竞争资源或者由于彼此通信的原因，**各个线程都在等待其他线程释放持有的资源，导致所有线程阻塞**，无法正常继续运行的现象。

* 死锁发生的**四个必要条件**：

  * **互斥条件**：线程必须对**互斥资源**存在竞争（区别于非互斥资源）；
  * **请求与保持条件**：当线程因请求某个资源而进入阻塞时，**不会释放自己已持有的资源**；
  * **不可剥夺（抢夺）条件**：线程所持有的资源，在未使用完毕之前**不可被其他线程剥夺（抢夺）**；
  * **循环等待条件**：各线程对资源的竞争存在**循环等待链**关系；

* 死锁产生的原因：

  * 系统互斥资源不足；
  * 线程推进执行顺序不当；
  * 互斥锁、信号量等使用不当。

  总之，对互斥资源的分配不可理时，可能发生死锁。

### 预防死锁

* 预防死锁的主要思想是**破坏死锁产生的四个必要条件中的一个或几个**。
* **破坏互斥条件**：将互斥资源改造为某种非互斥资源来使用，运行多个线程同时使用该资源；
* **破坏不可剥夺条件**：
  * 当一个线程请求某个资源失败时，**将自己持有的资源释放**；
  * 当一个线程请求某个资源失败时，**请求操作系统介入强行剥夺**；
  * 反复的申请和释放资源会导致系统开销增大，并且存在饥饿现象。
* **破坏请求与保持条件**：
  * 当一个线程请求某个资源失败时，**将自己持有的资源释放**；
  * **静态分配法**，即一次性请求所有所需资源，失败则不持有任何资源，但容易**造成资源使用率下降**，也会导致**饥饿**现象。
* **破坏循环等待条件**

### 避免死锁

* **安全序列**：能保证**各个线程顺利执行完毕的资源分配序列**。



* **大端小端**
  * 大端：逻辑高位在内存的低位 
    * 因为TCP/UDP/IP规定：**把接受到的第一个字节当作高位字节看待，而发送时的第一个字节应该是内存中处于地位地址的那个字节。也就是说内存中的低位起始地址的那个字节对应着传输数据的第一个高位字节。**可见，数值发送前，在内存中是以大端形式存放的。
  * 小端：逻辑低位在内存的低位
    * 逻辑和实际一致
  

# 堆和栈

|      |                分配方式                |                           使用情况                           |                           释放方式                           |
| :--: | :------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  堆  | 程序员手动分配，大小、结构由程序员决定 | 支持复杂的数据结构，在内存中向高地址拓展，存储空间并不连续。 | 通过函数库提供的函数手动释放；进程结束时由OS释放；Java虚拟机的垃圾回收机制自动释放。 |
|  栈  |             由系统自动分配             | 只支持基本的数据结构但却是函数调用所依赖的结构，在内存中向低地址拓展，是连续的存储空间。 | 栈中变量生命周期结束时其栈空间自动释放，栈空间在线程结束时自动释放 |

# 系统栈的结构

| **低地址** | **代码区（程序段）** |      **存放二进制机器代码**      |
| :--------: | :------------------: | :------------------------------: |
|            |    **静态数据区**    | **存放全局变量以及局部静态变量** |
|            |       **堆区**       |     **用于动态申请内存空间**     |
| **高地址** |       **栈区**       |  **用于函数调用，存放局部变量**  |

# ASCII码

* 大写字母：**65-90**
* 小写字母：**97-122**
* 数字：**48-57**

相同字母的大小写之间差距32

所以判断两个字符是否互为大小写，可以使用异或：c1 ^ c2 == 32。因为如果两个字母互为大小写，它们差为32，二进制串只有一个字符的差别。

# 前言

* *虽然 Docker 项目备受追捧，但用户们最终要部署的，还是他们的网站、服务、数据库，甚至是云计算业务。**

* 容器本身没有价值，有价值的是“容器编排”。

* 容器技术的核心功能，就是**通过约束和修改进程的动态表现，从而为其创造出一个“边界”**，其中，Cgroups 技术是用来**制造约束**的主要手段，而 Namespace 技术则是用来**修改进程视图**的主要方法。

* 对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：
  * **启用 Linux Namespace 配置；**
  * **设置指定的 Cgroups 参数；**
  * **切换进程的根目录（Change Root）。**


# 虚拟机与容器

![img](https://static001.geekbang.org/resource/image/d1/96/d1bb34cda8744514ba4c233435bf4e96.jpg?wh=2242*1163)

### 虚拟机

* **Hypervisor**是虚拟机最主要的部分：它通过**硬件虚拟化功能**，模拟出了运行一个操作系统需要的各种硬件（比如 CPU、内存、I/O 设备），然后在这些虚拟的硬件上就可以安装一个新的操作系统，即 **Guest OS**。

### 容器

* 跟真实存在的虚拟机不同，在使用 Docker 的时候，**并没有一个真正的“Docker 容器”运行在宿主机里面**。
* Docker 启动，依然还是原来的应用进程，只不过在创建这些进程时，为它们**加上了各种各样的 Namespace、Cgroups参数等等**。

### 两者对比

* 首先，不能把Docker Engine或者类似的容器管理工具与 Hypervisor **划等号**，它们并不像 Hypervisor 那样对应用进程的隔离环境负责，也不会创建任何实体的“容器”，真正对隔离环境负责的是**宿主机操作系统本身**。
* **性能方面**：
  * 使用虚拟化技术作为**应用沙盒**，就必须要由 Hypervisor 来负责创建虚拟机，这个虚拟机是真实存在的，里面也必须运行完整的 Guest OS 才能执行用户的应用进程。**这就不可避免地带来了额外的资源消耗和占用。**
  * 此外，用户应用对宿主机操作系统的调用也会**不可避免地被虚拟化软件拦截和处理**，这本身又是一层性能损耗，尤其是**计算资源、网络和磁盘 I/O**。
  * 相比之下，容器就是宿主机上的一个普通程序，这意味着**根本不存在因为虚拟化而带来的性能损耗**；另一方面，容器运行不需要单独的 Guest OS，使得容器**不需要额外的镜像空间和性能占用**。
* **隔离方面：**
  * 既然容器是宿主机上一个个进程，那么多个容器肯定会共享同一宿主机上的同一套内核，这种隔离并不彻底。
  * 并不是所有宿主机上的资源都可以通过Namespace和Cgroup来进行隔离和限制。

# Namespace

* 使用Namespace，可以**将单个进程的进程空间视图与宿主机隔离开来，使得每个进程只能看到当前 Namespace 所限定的资源、文件、设备、状态，或者配置（例如PID、mount挂载、网络设备等）**，看不到宿主机信息，进而也更看不到其他进程空间内的信息，**达到一种“容器隔离”的效果**。
* 但其实就是**“障眼法”**罢了，容器就是一种特殊的进程而已。

### Namespace文件

* 每个进程的**每种 Linux Namespace**，都在它对应的 **`/proc/[进程号]/ns`** 下有一个对应的虚拟文件，并且链接到一个真实的 Namespace 文件上。

# Cgroups（Control Group）

* 用于限制一个**进程组**能够使用的**资源上限**，包括 CPU、内存、磁盘、网络带宽等等。
* 在`/sys/fs/cgroup/`目录下，有多个子目录，这些子目录称为**子系统**。
* 在`/sys/fs/cgroup/cpu`目录下，也有多个子目录，这些子目录称为**cpu子系统的控制组**。
* 在子系统或者控制组中，有一个**`tasks`文件**，它记录了该子系统或者控制组管理的进程号。
* 在子系统或者控制组中，有很多**配置文件**，它们记录了对该子系统或控制组中的进程进行的限制参数。
* 对于容器项目来说，**只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录**），然后在启动容器进程之后，把该容器进程的 PID 填写到对应控制组的 tasks 文件中就可以了。
* 对于 docker 来说，**会默认在子系统下面创建一个名为 docker 的子目录**，再在其中为每个容器（或几个容器）创建对应控制组。

# rootfs

* 在容器进程启动之前重新挂载它的整个根目录“/”，由于 Mount Namespace 的存在，所以这个挂载对宿主机不可见。
* rootfs 只是一个操作系统所包含的文件、配置和目录，**并不包括操作系统内核**，在 Linux 中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。所以说，**rootfs 只包括了操作系统的“躯壳”，并没有包括操作系统的“灵魂”。**
* 由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起，**而对一个应用来说，操作系统本身就是它运行所需要的最完整的“依赖库”。**

### 分层镜像

* 由于容器镜像的操作是增量式的，每次镜像拉取、推送的内容，比原本多个完整的操作系统的大小要小得多；而**共享层**的存在，使得**所有这些容器镜像存储需要的总空间，也比每个镜像的总和要小。**

### UnionFS（联合文件系统）

* 将多个不同位置的目录**联合挂载（union mount）**到同一个目录下。

* 推荐使用 **OverlayFS**。这是因为 OverlayFS 是 Linux 内核的一部分，并且在大多数发行版中已经默认启用，因此具有广泛的支持和较好的稳定性。

* 镜像各个层保存在 `/var/lib/docker/.../diff` 目录下，在容器进程启动后，它们会被联合挂载在 `/var/lib/docker/.../mnt/` 目录中，**这样容器所需的rootfs就准备好了**。

### Volume挂载

* **在rootfs准备好之后，在执行`chroot`之前**，把 Volume 指定的宿主机目录（比如 /home 目录），挂载到指定的容器目录（比如 /test 目录）在宿主机上对应的目录（即 `/var/lib/docker/.../mnt/[可读写层 ID]/test`）上，Volume 的挂载工作就完成了。
* 由于执行挂载操作时，“容器进程”已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，挂载事件只在这个容器里可见。在宿主机上，是看不见容器内部的这个挂载点的。**这就保证了容器的隔离性不会被 Volume 打破**。

### 只读层

* 静态镜像的所有层都是以只读方式联合挂载的。

### 可读可写层

* 用来存放修改 rootfs 后产生的**增量**（无论是增、删、改）。
* 当我们使用完了这个被修改过的容器之后，还可以使用 docker commit 和 push 指令，保存这个被修改过的可读写层。
* 所有的增量内容，都会体现在`/var/lib/docker`下的`diff`目录里

### init层

* 是一个以“-init”结尾的层，夹在只读层和读写层之间。
* 专门用来存放启动容器时，**临时设置的值（例如/etc/hosts、/etc/resolv.conf中的信息），仅对当前容器有效**，并不愿意被提交到新镜像中。
* 往往init层中包含`dev、etc、proc、sys`等目录内容。

# 容器的真正价值

### 容器的本质

* “容器”，实际上是一个由 **`Linux Namespace、Linux Cgroups 和 rootfs`** 三种技术构建出来的**进程隔离环境**。
  * 一组联合挂载在宿主机上的 rootfs，这一部分称为**“容器镜像”（Container Image），是容器的静态视图**；
  * 一个由 Namespace+Cgroups 构成的隔离环境，这一部分称为**“容器运行时”（Container Runtime），是容器的动态视图**。

### 容器、容器编排和云的真正价值

* 开发者并不关心容器运行时的差异，在整个“开发 - 测试 - 发布”的流程中，真正承载着容器信息进行传递的，是**容器镜像**，而不是容器运行时，即**开发者只关心自己的应用程序是否正常运行**。
* 作为一家云服务商或者基础设施提供商，只要能够将用户提交的 Docker 镜像以容器的方式运行起来，就能成为这个非常热闹的容器生态图上的一个承载点，从而将整个容器技术栈上的价值，沉淀在这个节点上。
* 更重要的是，只要从这个承载点向 Docker 镜像制作者和使用者方向回溯，整条路径上的各个服务节点，比如 **CI/CD、监控、安全、网络、存储等等**，都有可以发挥和盈利的余地。这个逻辑，正是所有云计算提供商如此热衷于容器技术的重要原因：通过容器镜像，它们可以和潜在用户（即，开发者）直接关联起来。

# Dockerfile

* Dockerfile 中的每个原语执行后，**都会生成一个对应的镜像层**。

### ENTRYPOINT & CMD

* **默认情况下，Docker 会提供一个隐含的 ENTRYPOINT：`/bin/sh -c`**，即 CMD 的内容就是 ENTRYPOINT 的参数。
* 在不指定 ENTRYPOINT 时，那么实际运行的命令就是`/bin/sh -c <CMD的值>`

# Docker命令

### docker exec

* 使用**setns()系统调用**，根据某个容器进程的 **Namespace 文件**（`/proc/[pid]/ns/`目录下），加入到该进程已有的 Namespace 当中，从而达到“进入”该容器的目的。

### docker run

###### 参数

* `-p`：-`p 4000:80`把容器内的 80 端口映射在宿主机的 4000 端口上

# 语言定位

* **强类型**语言：
  * 变量声明定义后，**若不进行强制转换，变量类型不会随着环境变化而变化。**
* **静态型**语言：
  * 在变量声明时**必须指定变量类型（不过Go可以自动推导），在编译时会进行检查。**
* **编译型**语言
* **跨平台编译型**语言

# Golang配置

* GoPath：存放工程代码的目录位置，需要加入到**环境变量“GOPATH”**中

  * src：源代码

  * bin：可执行文件，需要加入**环境变量“PATH”**中

  * pkg：中间状态包

* GOROOT：安装的go.exe文件位置，需加入到**环境变量“PATH”**中。

* 配置GoPath和GoRoot：

  * 将go安装包解压至**`/usr/local`**：

    ```shell
    tar -zxvf go1.18.linux-amd64.tar.gz -C /usr/local
    ```


  * 在**`/root`**下创建`GoPath`文件夹


  * 配置环境变量：

    ```shell
    vim /etc/profile
    ```

    将以下内容添加到profile文件中：

    ```shell
    export GOROOT=/usr/local/go
    export GOPATH=/root/GoPath
    export GOBIN=$GOPATH/bin
    export PATH=$PATH:$GOROOT/bin
    export PATH=$PATH:$GOPATH/bin
    ```

    使配置生效：

    ```shell
    source /etc/profile
    ```



# go命令适用

* **go build（编译链接，生产可执行文件）**：

  * 在对应目录下直接go build

  * 在任意目录下 go build <文件路径中src后面的路径>

  * go build -o <name.exe>


* **go run（直接运行源代码文件）**

* **go install（生成可执行文件并添加至pkg目录）**


# 包（package）

* 包（package）是多个Go源代码的**集合**，用于提供基本的代码复用功能。
* 同属于同一个包`packageName`的所有源代码文件，首行有效代码必须为**`package packageName`**，同于声明自己所在的包。
* 一个目录下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。
* 包可以定义在很深的目录中，**包的定义不用包括目录路径**，但是**包在引用时一般使用全路径引用**。比如在`GOPATH/src/a/b/ `下定义一个包 c。在包 c 的源码中只需声明为**`package c`**，而不是声明为`package a/b/c`，但是在导入 c 包时，需要带上路径，例如**`import "a/b/c"`**，并且`import`的包必须在程序中使用，否则编译报错。
* 包名为`main`的包为**应用程序包**，将其`go build`编译会得到**可执行文件**。
* **！！！！！**对于包中的变量、类型、函数、方法，**只有大写字母开头才能够被外部调用。**

# 交叉编译

* golang语言支持**跨平台编译**，在使用时需要设置**两个环境变量**：
  * **GOOS：运行的目标平台**（当然，不同平台设置环境变量的语句不同）
    * **mac：GOOS=darwin**
    * **linux：GOOS=linux**
    * **windows：GOOS=windows**
  * **GOARCH：运行的目标CPU架构**
    * **386：GOARCH=386**
    * **amd64：GOARCH=amd64**
    * **arm：GOARCH=arm**

# 函数

* 在Go里面，函数是**头等（一等）**的，它能被用在整数、字符串和其他类型能用的地方：
  * **将函数赋给变量**
  * **将函数作为参数传递给函数**
  * **将函数作为函数的返回值**

# 面向对象思想

* 在C++、Java等面向对象语言中，拥有**类、对象、继承**等面向对象的概念，但Go语言中**不提供这些语法**，却可以**通过其他方式实现面向对象思想。**

### 方法的关联

* 在C++、Java等面向对象语言中，方法属于类，通过类来使用方法。

* 在Go中提供了方法，但**没提供类和对象**，仅仅允许**将类型和方法关联起来，从而变为更加灵活。**关联后，就可以通过该类型的变量直接调用该方法。

* 若将**方法**和**一个结构体类型**进行关联，那么便可理解为：**结构体类型**就是**类**；**结构体变量**就是**对象**；**和结构体类型关联的方法**就是该**对象的方法**。

* 未和变量关联的函数可以有多个参数，但是和变量关联的方法有且仅有一个**接收者**。

* 在**不实现接口**的情况下，无论方法的**接收者**是**值类型**还是**指针类型**，也无论方法的**调用者**是**值类型**还是**指针类型**，方法都可以正常被调用，编译和运行不会出错：

  * |                  |                        接收者为值类型                        |                       接受者为指针类型                       |
    | :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
    |  调用者为值类型  |                 拷贝一个**值副本**，传值调用                 | 进行**自动引用**，然后将引用地址进行拷贝，生成一个**指针副本**，新拷贝的指针仍然指向原对象 |
    | 调用者为指针类型 | 进行**自动解引用**，然后将解引用后的值进行拷贝，生成一个**值副本** |       拷贝一个**指针副本**，新拷贝的指针仍然指向原对象       |

  * 可以看到：**值接收者**方法进行的修改操作**并不影响调用者**，**指针接收者**方法进行的修改操作**会影响调用者**。

### 嵌入类型

* Go语言中**没有类、继承等概念**，但是可以通过将一个类型**组合**或者**嵌入**到另一个结构体中，实现“继承”思想。
* 嵌入的类型为**内部类型**，被嵌入的类型为**外部类型**，通过嵌入，就可以实现**外部类型“继承”内部类型**的思想。

### 转发

* 通过嵌入类型，**与内部类型相关联的所有字段、方法、标志符**等等所有，都会被**转发**到外部类型，**被外部类型所拥有**（就像**子类可以使用父类所拥有的公开变量、方法**一样）。这就达到了代码快捷复用组合的目的，而且定义非常简单，只需声明这个类型的名字就可以了。
* 很显然，这种模式相当于**“一个类可以继承多个类”**，这会出现**转发时的冲突**：
  * 若多个内部类型，它们有着**相同名字**的方法、变量、字段，若外部类型使用**`外部类型变量.字段（方法）`**这种方式**直接调用**，将发生冲突
  * 这时可以**不直接调用**，转而使用**`外部类类型变量.内部类型.字段（方法）`**这种形式进行**无歧义**地调用
  * 或者让**外部类型关联一个也是相同名字的方法**，这样外部类型关联的方法优先级高，会**被优先调用**，这样就不存在多个内部类型方法转发时，出现冲突的情况了。

### 接口

* Go语言中**接口的实现是隐式的**：只要声明了接口A，再声明了满足接口的类型B，那么**B类型就自动地实现了接口A**，而无需多余的代码。

* 接口值有两部分组成,：

  * 一个指向**该接口的具体类型**的指针
  * 一个指向**该具体类型真实数据**的指针

  只有**这两个指针都为`nil`**时，该接口值才为`nil`。

* 若一个类型满足了一个接口，那么该类型的指针也满足这个接口；但是一个类型的指针满足某个接口，该类型是不满足这个接口的。

# 切片

### 切片的实质

* 一个切片实质上是对一个**底层数组**切分的**窗口（或者视图）**：

  ```go
  type slice struct {
  	array unsafe.Pointer // 指向底层数组的元素指针
  	len   int // 长度 
  	cap   int // 容量
  }
  ```

* 切片也有类型，只不过**不包括切片长度，只有元素类型**（不同于数组）。
* **长度**为切片**元素的个数**，而**容量**为切片**底层数组元素的个数**。
* 也可以对字符串`string`进行切分，不过**切分的索引是字节数，而不是字符数**。
* 由于切片指向底层数组，相当于一个**指针**，所以：
  * 修改一个切片的某个元素值，会一起修改底层数组对应元素值
  * 修改一个数组某个元素值，会一起修改指向它的所有切片的对应元素值

### 切片的动态变化

* 使用`append()`函数可向一个切片添加元素

* 添加后根据**长度是否超出原始容量**，可分为两种情况：

  * 添加后，长度超过原始容量，导致**扩容**：此时Golang会**在另一个内存地址上创建一个新的底层数组**，新数组的容量大小会比原始的数组容量大。这时，**新切片指向的是这个新数组，而不是原来的数组了**，所以对新切片和新数组进行操作，不会影响到原数组和原切片。

  * 添加后，长度未超过原始容量，**不会导致扩容**：此时Golang**不会创建新的数组**，**新切片指向的也是原来的数组**。值得注意的是，由于依旧指向原数组，那么向原切片添加新元素后，**会覆盖掉原数组对应位置的元素**，使它们成为**新元素值**。

    ```go
    	arr := [...]int{1, 2, 3, 4, 5, 6}
    	s1 := arr[:5]
    	s2 := append(s1, 10) // 此次向原切片添加元素并没有触发扩容，所以新切片依旧指向原数组，并且覆盖了原数组中的对应元素
    	s2[4] = 100
    	fmt.Println(arr)
    	fmt.Println(s1)
    	fmt.Println(s2)
    	fmt.Println(cap(s1), cap(s2))
    ```

    上述代码输出为：

    ```go
    	[1 2 3 4 100 10]
    	[1 2 3 4 100]
    	[1 2 3 4 100 10]
    	6 6
    ```

# 指针

* 若**两指针的值**相同，那么这两个指针就相同：

  ```go
  	s := 1
  	point1 := &s
  	point2 := &s
  	if point1 == point2 {
  		fmt.Println("yes")
  	}
  ```

  上述代码打印结果为“yes”

* **使用指针作为方法的接收者的策略**应该是**一致**的：若一个方法使用了某个类型的指针作为接收者，那么**该类型的所有方法**都应该使用**它的指针**作为接收者。

* 除了`map`和`slice`类型，其余类型的指针都可以进行**自动解引用**，毕竟在Go语言中，`map`和`slice`属于**隐式指针**。

* 若一个接口变量未被赋值，那么它的**类型和值**都是**`nil`**；并且只有在它的**类型和值都为`nil`**时，该接口变量才等于`nil`。

### for range中的指针

* for range 循环在每次迭代中生成两个值：索引和值；
* 在每一次循环中，该值实际上是同一个变量。

# 错误、异常、panic

* 使用`panic`比使用`os.Exit()`更好，因为`panic`后**依旧会执行`defer`的操作**。
* 若**`defer`的操作**中调用了**`recover()`**函数，那么`panic`将会停止，程序将继续运行。

# Goroutine与Channel

* Goroutine 只存在于 Go 语言的运行时，是 Go 语言的**用户态级线程**，作为一种**粒度更细**的资源调度单元，能够在高并发的场景下更高效地利用机器的 CPU。
* **单纯地并发执行goroutine是没有意义的，goroutine间的通信和共享才能体现并发的意义。**
* Go语言的并发模型是**CSP（Communicating Sequential Processes）**：
  * 提倡**通过通信实现共享内存，而不是通过共享内存实现通信**；
  * 虽然可以使用共享内存进行数据交换，但是容易发生竞态问题；并且还必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。

* channel是一种特殊的类型，总是遵循**先入先出（First In First Out）**原则。

* |      | 正常channel | 已关闭channel           | nil channel |
  | ---- | ----------- | ----------------------- | ----------- |
  | 读   | 读出数据    | 读出一个零值和一个false | 阻塞        |
  | 写   | 写入数据    | panic                   | 阻塞        |
  | 关闭 | 正常关闭    | panic                   | panic       |

* **无缓冲channel是阻塞式**的：
  
  * 传输者**在传输完数据后会一直阻塞等待**，直到接收者接收数据；
  * 接收方会**一直阻塞等待**，直到传输者传输数据。
  * 使用**无缓冲channel**进行通信将**导致发送和接收的goroutine同步化**，因此，无缓冲通道也被称为**同步通道**。

# GMP模型

* Go语言之所以被称为现代化的编程语言，就是因为它**在语言层面已经内置了调度和上下文切换的机制。**

### G（Goroutine）

* 存放着P绑定信息。

* | 状态         | 描述                                                |
  | ------------ | --------------------------------------------------- |
  | `_Grunnable` | **准备就绪**                                        |
  | `_Grunning`  | **被赋予了 M 和 P，正在运行**                       |
  | `_Gsyscall`  | 正在执行系统调用，被赋予了内核线程 M                |
  | `_Gwaiting`  | 由于运行时而被阻塞，可能存在于 Channel 的等待队列上 |

### P（Processor）

* **处理器，可以被看做运行在线程上的本地调度器，作为M 和 G 的中间层，管理着一组goroutine队列**，存储当前运行goroutine的上下文环境（函数指针，堆栈地址及地址边界）。

* 通过处理器 P 的调度，**每一个 M 都能够执行多个 G**，它能在 Goroutine 进行一些 I/O 操作时及时让出计算资源，提高线程的利用率。

* **GOMAXPROCS** 设置 P 的数量，即**最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。**

* | 状态        | 描述                                   |
  | ----------- | -------------------------------------- |
  | `_Pidle`    | 没有运行 G 或者调度器，运行队列为空    |
  | `_Prunning` | 被线程 M 持有，并且正在运行G或者调度器 |
  | `_Psyscall` | 运行G，当前 M 陷入系统调用             |

### M（Machine）

* go runtime对OS内核线程的虚拟。

### 调度原理

* 所有的 P 都在程序启动时创建，并保存在数组中；
* 新建 G‘ 时，G’ 优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列；
* M想运行任务就得**获取 P（绑定 P ）**，从 P 的本地队列获取 G；
* **work stealing**：P 队列为空时，尝试从其他 P 偷取 G，**而不是销毁线程**，或从其他 P 的本地队列偷一半放到自己 P 的本地队列（抢夺任务）；
* **hand off**：当 M 因为 G 进行系统调用阻塞时，**释放绑定的 P，把 P 转移给其他空闲的 M 执行**，或者新建一个M，将 P 挂载在新M上运行；
* **P会对自己管理的goroutine队列做一些管理和调度**，比如：把占用CPU时间较长的goroutine暂停，转而运行后续goroutine；

# 并发锁

### 互斥锁

* mutex互斥锁：

  ```golang
  type Mutex struct {
  	state int32
  	sema  uint32
  }
  ```

* **正常模式**：

  * 所有等待互斥锁的goroutine都会进入等待队列等待；
  * 当一个**正在运行的goroutine**申请锁时，**如果锁空闲**，**它会直接获取到互斥锁，而不用进入等待队列（由于它持续占有CPU）**，避免了入队出队和挂起唤醒带来的**不必要的资源消耗**；
  * 当一个**正在运行的goroutine**申请锁时，**如果锁被占用**，它会先判断是否满足进入自旋的条件，若满足则会**进入自旋持续循环等待**，这样也不用进入等待队列，进一步避免了资源消耗；
  * 可以看到，正常模式下互斥锁是一种**非公平锁**；
  * 若新申请锁的goroutine太多，原本在队列里面等待被唤醒的goroutine将会进入**饥饿状态**。

* **饥饿模式**：

  * 当一个 goroutine **等待时间超过 1ms**，互斥锁就会切换到饥饿模式；
  * 此时新的goroutine在申请锁时，**不会立刻获取锁，也不会进入自旋状态，而是直接被添加到等待队列的末尾**，锁会直接被交给**队列中最前面的goroutine**；
  * 当一个 goroutine **获得了互斥锁**，并且它**在队列的末尾或者等待的时间少于 1ms**，互斥锁将切换回正常模式。

* 可以看到，**正常模式下互斥锁能够提供更好地性能**，而**饥饿模式则能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时**。

* 尝试对一个已经解锁的互斥锁解锁，会**触发`panic`**，同时这种`panic`是`recover()`函数所**不能恢复**的。

* 关于互斥锁的用法注意:

  * 不能全局使用同一个 Mutex；

  * 不要将要加锁和解锁分到两个以上 Goroutine 中进行，否则容易形成死锁；

  * 不要复制 Mutex（包括不能通过参数传递），否则会复制传参前锁的状态：已锁定 or 未锁定，很容易产生死锁；

  * **尽量避免使用 Mutex**，如果非使用不可，尽量多声明一些 Mutex，采用取模分片的方式去使用其中一个 Mutex（分段锁）（尽量减小锁的颗粒度）


### 读写锁

* 当一个goroutine获取**读锁**之后，其他的goroutine如果**申请读锁会继续获得读锁，如果是申请写锁就会等待**；
* 当一个goroutine获取**写锁**之后，其他的goroutine无论是获取读锁还是写锁都会等待。
* 申请写锁时，会**先阻塞写锁后阻塞读锁**，再**等待其余goroutine的读操作和写操作结束**，这种策略能够保证**读操作不会被连续的写操作饿死**。
* 释放写锁时，会**先通知所有的读操作**，然后才会释放持有的互斥锁。

### 同步组

* `sync.WaitGroup` 可以等待一组 Goroutine 的返回，比较常见的使用场景是批量发出 RPC 或者 HTTP 请求：

  ```golang
  requests := []*Request{...}
  wg := &sync.WaitGroup{}
  wg.Add(len(requests))
  
  for _, request := range requests {
      go func(r *Request) {
          defer wg.Done()
          // res, err := service.call(r)
      }(request)
  }
  wg.Wait()
  ```

* 结构体如下：

  ```golang
  type WaitGroup struct {
  	noCopy noCopy
  	state1 [3]uint32
  }
  ```

* `nocopy` 保证了 `sync.WaitGroup` **不会被开发者通过再赋值的方式拷贝**，否则在编译阶段就会报错；

* `Add`可以更新 `wg` 中的计数器 `counter`：

  * 虽然 `Add`方法传入的参数可以为负数，**但是计数器只能是非负数**，一旦出现负数就会发生程序崩溃；
  * 当调用计数器归零，即所有任务都执行完成时，才会通过唤醒处于等待状态的 Goroutine。

*  `Wait`会在计数器大于 0 时让本 goroutine 陷入睡眠。

# Context上下文

* 上下文 [`context.Context`](https://draveness.me/golang/tree/context.Context) 是Go 语言中用来**设置截止日期、同步信号，传递请求数据的结构体**，它与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计。
* 在 Goroutine 树形结构中**对信号进行同步以减少资源的浪费**是 `context.Context` 的最大作用。
* 每一个`context.Context`都会**从最顶层的 Goroutine 一层一层传递到最下层**，可以**在某一层 Goroutine 执行出现错误时，将信号及时同步给下层，**及时停掉无用的工作，避免资源浪费。

### 接口实现

```golang
type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() <-chan struct{}
	Err() error
	Value(key interface{}) interface{}
}
```

* Context 接口定义了四个需要实现的方法：
  * `Deadline` ： 返回 Context 被取消的时间，也就是完成工作的截止日期；
  * `Done` ：返回一个 Channel，该 Channel 会在**当前工作完成**或者**上下文被取消后**关闭，多次调用 `Done` 方法会返回同一个 Channel；
  * `Err`： 返回 Context 结束的原因，它只会在`Done`方法对应的 Channel 关闭时返回非空的值；
    * 如果`Done()`未被关闭，返回 nil；
    * **如果 context 被取消，会返回 `Canceled` 错误**；
    * **如果 context 超时，会返回 `DeadlineExceeded` 错误**；

  * `Value` — 从 context 中获取键对应的值，对于同一个上下文来说，多次调用 `Value` 并传入相同的 `Key` 会返回相同的结果，该方法可以**用来传递请求特定的数据**；

* 实际使用当中，参数传递的是 `context.Context` 接口的值副本，但该副本内部**包含了指向实际上下文对象的指针**。因此，所有对上下文的修改（**如取消、超时等**）都能在其他共享该上下文的地方反映出来。

### 默认上下文

* `context` 包中最常用的方法还是 **`context.Background()`和`context.TODO()`**，这两个方法都会返回预先初始化好的**私有变量 `background` 和 `todo`**。

  ```golang
  func Background() Context {
  	return background
  }
  
  func TODO() Context {
  	return todo
  }
  ```

* 从源代码来看，`context.Background`和 `context.TODO`也只是**互为别名**，没有太大的差别，只是在使用和语义上稍有不同：

  - **`context.Background`是上下文的默认值，所有其他的上下文都应该从它衍生出来；**
  - `context.TODO`应该仅在不确定应该使用哪种上下文时使用。

### 取消信号

* `context.WithCancel` 函数能够从 `context.Context` 中**衍生出一个新的子上下文并返回用于取消该上下文的函数**。

  ```golang
  func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
  	c := withCancel(parent)
  	return c, func() { c.cancel(true, Canceled, nil) }
  }
  ```

* 除了 `context.WithCancel` 之外，另外两个函数 **`context.WithDeadline` 和 `context.WithTimeout`** 也都能创建可以被取消的计时器上下文 `context.timerCtx`。

* 一旦我们执行返回的取消函数，**当前上下文以及它的子上下文都会被取消，所有的 Goroutine 都会同步收到这一取消信号。**

### 传值方法

*  `context.WithValue` 能从父上下文中创建一个子上下文，其**带有一对key和value**，用于**对协程做同步或者传递上下文变量给其他协程**，这样可以避免在协程之间传递大量的变量，代码更整洁可维护。

  ```golang
  func WithValue(parent Context, key, val any) Context {
  	if parent == nil {
  		panic("cannot create context from nil parent")
  	}
  	if key == nil {
  		panic("nil key")
  	}
  	if !reflectlite.TypeOf(key).Comparable() {
  		panic("key is not comparable")
  	}
  	return &valueCtx{parent, key, val}
  }
  ```

* contex.valueCtx.Value()方法会转发到父上下文中：

  ```golang
  type valueCtx struct {
  	Context
  	key, val any
  }
  
  // 对Context接口的Value()方法实现
  func (c *valueCtx) Value(key any) any {
  	if c.key == key {
  		return c.val
  	}
      // 内部其实是一个递归
  	return value(c.Context, key)
  }
  ```

* 如果 `context.valueCtx` 中存储的键值对与 `Value()` 方法中传入的参数不匹配，**就会从父上下文中查找该键对应的值，直到某个父上下文中返回 `nil` 或者查找到对应的值。**

# 垃圾回收

* Golang拥有自己的 Garbage Collector（垃圾回收机制），开发时可以不手动释放资源。

# 垃圾回收GC

### 引用计数法

* 根据对象的引用计数判断是否回收，当计数归零时则进行回收；
* 计数开销大，存在循环引用问题。

### 标记-清除算法

* 在标记阶段**从根对象开始，通过可达性分析**把要回收的对象进行标记，在清除阶段统一回收垃圾对象；
* 效率不高，且存在严重的**内存碎片问题**，可能会因此反复触发垃圾回收流程。

### 复制算法

* 在标记-清除算法的基础之上，**将内存空间分为两部分**，申请内存时只使用其中的一部分；
* 在进行对象回收时，**直接将该块内存中存活的对象复制到另一块内存中去**，然后直接全部清除该块内存；
* 适用于新生代对象较多的情况，因为这样复制次数会大大减少；
* 复制对象过程会有性能消耗，**内存使用效率直接减半**。
* 优化：
  * 在复制算法基础上，**将内存空间分为三部分，一块占用80%空间的Eden区，两块各占用10%空间的Survivor区**；
  * 每次使用内存都只使用Eden区和其中一块Survivor区；
  * GC 时，**把 Eden 区和 Survivor 区存活的对象全部复制到另一块 Survivor 区中**，然后清理掉 Eden 区和刚刚用过的 Survivor 区；
  * 内存使用效率为90%+；

### 标记-整理算法

* 在标记-清除算法的基础之上，将对象进行标记后，并不直接清除对象，而是**将存活对象移动到内存的一端**，然后直接清理掉剩余部分；
* 解决了内存碎片问题，但依旧存在性能问题。

### 分代收集算法

* 根据存活时间的长短（或者经历的GC次数多少）将不同对象分为新生代和老年代，大部分对象都为新生代对象；
* 对于新生代对象，一般采用复制算法，因为**这适用与短期对象较多的情况；**
* 对于老年代对象，一般采用标记-清除或者标记整理算法，因为**老年代对象生命周期较长，不适合频繁复制；**
* 大大提高了整体的GC效率；
* 实现复杂，且新生代晋升为老年代的阈值决策可能会影响整体性能。

### **增量收集（Incremental GC）和并发收集（Concurrent GC）**

* 将完整的垃圾回收过程分成多个小步骤，**每次回收一小部分，减少因GC造成的停顿时间**；
* 在用户线程运行同时**并发进行垃圾回收**，尽量减少 GC 对应用的影响；
* 显著降低了GC引起的停顿时间，提高了应用程序的响应性和用户体验；
* 某些阶段依旧需要执行STW操作。

# Golang GC算法

* golang 的 GC 目前使用的是：**无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）**的**三色标记清扫**算法。

### STW

* 通常意义上指代从 `Stop the World` 这一动作发生时到 `Start the World` 这一动作发生时这一段时间间隔，即**万物静止**；
* 在GC过程中为了保证**实现的正确性、防止无止境的内存增长等问题**而不可避免的需要**停止赋值器进一步操作对象图**；
* 在这个过程中整个用户代码被停止或者放缓执行， `STW` 越长，对用户代码造成的影响（例如延迟）就越大。

### 根对象集合

* **全局变量**：在编译期就能确定将存在于程序整个生命周期的变量；

* **执行栈**：每个 goroutine 都包含自己的执行栈，这些执行栈上包含**某些变量**和**指向分配的堆内存区块的指针**；

* **寄存器**：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

### 三色标记法

* 三色抽象规定了三种不同类型的对象：

  * **白色**：未被回收器扫描到的对象，回收阶段开始时，所有对象都是白色对象；

  * **灰色**：已被回收器扫描到的对象，但是**其包含的字段还未被扫描**；

  * **黑色**：已被回收器扫描到的对象，**不存在任何引用外部指针**或者**从根对象可达**。
* 标记过程如下：
  * 最开始所有对象皆为白色对象；
  * 将所有根对象标记为灰色，放入灰色队列；
  * 从灰色队列中取出对象，遍历其引用的对象，并标记为灰色；
  * 当一个灰色对象所有的引用对象被遍历后，将该灰色对象标记为黑色；
  * 直到**灰色队列为空**，此时所有的对象**非黑即白**，白色即为不可达的垃圾对象。

### 屏障机制

* 想要在**并发或者增量**的标记算法中保证正确性，需要达成以下两种**三色不变性（Tri-color invariant）**中的一种：

  - **强三色不变性**：黑色对象**不会指向白色对象**，只会指向灰色对象或者黑色对象（这样自然白色对象就不会被遗漏）；

  - **弱三色不变性**：黑色对象可以指向白色对象，**但该白色对象必须包含一条从灰色对象经由多个白色对象的可达路径**（即使黑色对象指向了白色对象，但依旧存在一条未经访问的路径，使得扫描器能够扫描到该白色对象，这样白色对象也不会被遗漏）。

* **把回收器视为对象，把赋值器视为影响回收器这一对象的实际行为（即影响 GC 周期的长短）**，从而引入赋值器的颜色：
  - 黑色赋值器：已经由回收器扫描过，不会再次对其进行扫描；

  - 灰色赋值器：尚未被回收器扫描过或尽管已经扫描过，但仍需要重新扫描。

###### 插入写屏障

当一个对象新引用另一个对象时，**若另一对象为白色对象，将其标记为灰色。**

* 无论是新创建对象，还是更改下游对象引用关系，只要新下游是白色对象，统一将其标记为灰色，所以这是一种比较保守的屏障技术；

* 将可能存活的对象标记为灰色，进而**直接满足强三色不变性**，因为这样可以保证永远没有黑色对象指向白色对象的情况；

* 两种错误情况：

  * 当对象A指向对象B的指针更改为指向对象C时，对象B此时可能是垃圾对象，但其颜色可能为灰色或者黑色；
  * 当对象C被标记为灰色后，指向对象C的指针又重新指向了对象B，此时对象C也可能是垃圾对象，但其颜色已经为灰色；

  这些情况将在下一轮的GC过程中被纠正。

* 每次进行**指针赋值操作**时，都需要引入写屏障，这无疑会增加大量性能开销，所以为了避免造成性能问题，Golang **没有为所有栈上的指针写操作启用写屏障**，而是在标记终止阶段时启用 STW 对栈**重新扫描**。

###### 删除写屏障

当指向一个对象的引用被删除时，**若该对象为白色对象，将其标记为灰色。**

* 和插入写屏障一样，存在某些垃圾对象应该被回收，但是只能在下一轮循环中被回收的情况。

###### 混合屏障

参考文章：https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%86%99%E5%B1%8F%E9%9A%9C/2020/07/24/gc5.html

* GC 开始时将栈上可达对象全部标记为黑色（不需要二次扫描，无需 STW）
* GC 期间，任何栈上创建的新对象均为黑色
* 被删除引用的对象标记为灰色
* 被添加引用的对象标记为灰色

### 触发时机

* 系统触发：
  * 当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时；
  * 当距离上一个 GC 周期的时间超过一定时间（默认 2 分钟）时；
* 手动触发：开发者在业务代码中自行调用 `runtime.GC` 方法
  * 需要手动强制触发的场景极其少见，可能会是在某些业务方法执行完后，考虑到会占用大量内存，需要人为释放。

* 决定触发时机的因素：
  * 程序内存分配量
  * 系统整体内存压力
  * 程序的并发度（避免在高并发时频繁触发GC）
  * CPU使用率（避免在高负载时频繁触发GC）

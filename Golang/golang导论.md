# 语言定位

* **强类型**语言：
  * 变量声明定义后，**若不进行强制转换，变量类型不会随着环境变化而变化。**
* **静态型**语言：
  * 在变量声明时**必须指定变量类型（不过Go可以自动推导），在编译时会进行检查。**
* **编译型**语言
* **跨平台编译型**语言

# GoPath&GoRoot

### GoPath

* 存放工程代码的目录位置，需要加入到**环境变量“GOPATH”**中
  * src：源代码
  * bin：可执行文件，需要加入**环境变量“PATH”**中
  * pkg：中间状态包

### GOROOT

* 安装的go.exe文件位置，需加入到**环境变量“PATH”**中。

### 配置GoPath和GoRoot

* 将go安装包解压至**`/usr/local`**：

  ```shell
  tar -zxvf go1.18.linux-amd64.tar.gz -C /usr/local
  ```

* 在**`/root`**下创建`GoPath`文件夹

* 配置环境变量：

  ```shell
  vim /etc/profile
  ```

  将以下内容添加到profile文件中：

  ```shell
  export GOROOT=/usr/local/go
  export GOPATH=/root/GoPath
  export GOBIN=$GOPATH/bin
  export PATH=$PATH:$GOROOT/bin
  export PATH=$PATH:$GOPATH/bin
  ```

  使配置生效：

  ```shell
  source /etc/profile
  ```

# VSCode下go-outline等插件安装失败

* 失败是因为国内访问外部某些网站失败。

* 改用国内代理即可：

  ```
  go env -w GO111MODULE=on 
  go env -w GOPROXY=https://goproxy.cn,direct
  ```


# 相关终端命令

### go build（编译链接，生产可执行文件）

* 在对应目录下直接go build
* 在任意目录下 go build <文件路径中src后面的路径>
* go build -o <name.exe>

### go run（直接运行源代码文件）

### go install（生成可执行文件并添加至pkg目录）

# 下载安装（Linux）

* 下载：

  ```shell
  curl -L https://go.dev/dl/go1.17.3.linux-amd64.tar.gz
  ```

* 安装：

  ```shell
  rm -rf /usr/local/go && tar -C /usr/local -xzf go1.17.3.linux-amd64.tar.gz
  export PATH=$PATH:/usr/local/go/bin
  ```

* 查看版本：

  ```shell
  go version
  ```
  
* 启用Go mod

  ```shell
  go env -w GO111MODULE=on 
  ```

* 改用国内代理

  ```shell
  go env -w GOPROXY=https://goproxy.io,direct
  ```


# 包（package）

* 包（package）是多个Go源代码的**集合**，用于提供基本的代码复用功能。
* 同属于同一个包`packageName`的所有源代码文件，首行有效代码必须为**`package packageName`**，同于声明自己所在的包。
* 一个目录下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。
* 包可以定义在很深的目录中，**包的定义不用包括目录路径**，但是**包在引用时一般使用全路径引用**。比如在`GOPATH/src/a/b/ `下定义一个包 c。在包 c 的源码中只需声明为**`package c`**，而不是声明为`package a/b/c`，但是在导入 c 包时，需要带上路径，例如**`import "a/b/c"`**，并且`import`的包必须在程序中使用，否则编译报错。
* 包名为`main`的包为**应用程序包**，将其`go build`编译会得到**可执行文件**。
* **！！！！！**对于包中的变量、类型、函数、方法，**只有大写字母开头才能够被外部调用。**

# 交叉编译

* golang语言支持**跨平台编译**，在使用时需要设置**两个环境变量**：
  * **GOOS：运行的目标平台**（当然，不同平台设置环境变量的语句不同）
    * **mac：GOOS=darwin**
    * **linux：GOOS=linux**
    * **windows：GOOS=windows**
  * **GOARCH：运行的目标CPU架构**
    * **386：GOARCH=386**
    * **amd64：GOARCH=amd64**
    * **arm：GOARCH=arm**

# 函数

* 在Go里面，函数是**头等（一等）**的，它能被用在整数、字符串和其他类型能用的地方：
  * **将函数赋给变量**
  * **将函数作为参数传递给函数**
  * **将函数作为函数的返回值**

# 面向对象思想

* 在C++、Java等面向对象语言中，拥有**类、对象、继承**等面向对象的概念，但Go语言中**不提供这些语法**，却可以**通过其他方式实现面向对象思想。**

### 方法的关联

* 在C++、Java等面向对象语言中，方法属于类，通过类来使用方法。

* 在Go中提供了方法，但**没提供类和对象**，仅仅允许**将类型和方法关联起来，从而变为更加灵活。**关联后，就可以通过该类型的变量直接调用该方法。

* 若将**方法**和**一个结构体类型**进行关联，那么便可理解为：**结构体类型**就是**类**；**结构体变量**就是**对象**；**和结构体类型关联的方法**就是该**对象的方法**。

* 未和变量关联的函数可以有多个参数，但是和变量关联的方法有且仅有一个**接收者**。

* 在**不实现接口**的情况下，无论方法的**接收者**是**值类型**还是**指针类型**，也无论方法的**调用者**是**值类型**还是**指针类型**，方法都可以正常被调用，编译和运行不会出错：

  * |                  |                        接收者为值类型                        |                       接受者为指针类型                       |
    | :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
    |  调用者为值类型  |                 拷贝一个**值副本**，传值调用                 | 进行**自动引用**，然后将引用地址进行拷贝，生成一个**指针副本**，新拷贝的指针仍然指向原对象 |
    | 调用者为指针类型 | 进行**自动解引用**，然后将解引用后的值进行拷贝，生成一个**值副本** |       拷贝一个**指针副本**，新拷贝的指针仍然指向原对象       |

  * 可以看到：**值接收者**方法进行的修改操作**并不影响调用者**，**指针接收者**方法进行的修改操作**会影响调用者**。

### 嵌入类型

* Go语言中**没有类、继承等概念**，但是可以通过将一个类型**组合**或者**嵌入**到另一个结构体中，实现“继承”思想。
* 嵌入的类型为**内部类型**，被嵌入的类型为**外部类型**，通过嵌入，就可以实现**外部类型“继承”内部类型**的思想。

### 转发

* 通过嵌入类型，**与内部类型相关联的所有字段、方法、标志符**等等所有，都会被**转发**到外部类型，**被外包类型所拥有**（就像**子类可以使用父类所拥有的公开变量、方法**一样）。这就达到了代码快捷复用组合的目的，而且定义非常简单，只需声明这个类型的名字就可以了。
* 很显然，这种模式相当于**“一个类可以继承多个类”**，这会出现**转发时的冲突**：
  * 若多个内部类型，它们有着**相同名字**的方法、变量、字段，若外部类型使用**`外部类型变量.字段（方法）`**这种方式**直接调用**，将发生冲突
  * 这时可以**不直接调用**，转而使用**`外部类类型变量.内部类型.字段（方法）`**这种形式进行**无歧义**地调用
  * 或者让**外部类型关联一个也是相同名字的方法**，这样外部类型关联的方法优先级高，会**被优先调用**，这样就不存在多个内部类型方法转发时，出现冲突的情况了。

### 接口

* Go语言中**接口的实现是隐式的**：只要声明了接口A，再声明了满足接口的类型B，那么**B类型就自动地实现了接口A**，而无需多余的代码。

* 接口值有两部分组成,：

  * 一个指向**该接口的具体类型**的指针
  * 一个指向**该具体类型真实数据**的指针

  只有**这两个指针都为`nil`**时，该接口值才为`nil`。

* 若一个类型满足了一个接口，那么该类型的指针也满足这个接口；但是一个类型的指针满足某个接口，该类型是不满足这个接口的。

# 切片

### 切片的实质

* 一个切片实质上是对一个**底层数组**切分的**窗口（或者视图）**：

  ```go
  type slice struct {
  	array unsafe.Pointer // 指向底层数组的元素指针
  	len   int // 长度 
  	cap   int // 容量
  }
  ```

* **长度**为切片**元素的个数**，而**容量**为切片**底层数组元素的个数**。
* 由于切片指向底层数组，相当于一个**指针**，所以：
  * 修改一个切片的某个元素值，会一起修改底层数组对应元素值
  * 修改一个数组某个元素值，会一起修改指向它的所有切片的对应元素值

### 切片的动态变化

* 使用`append()`函数可向一个切片添加元素

* 添加后根据**长度是否超出原始容量**，可分为两种情况：

  * 添加后，长度超过原始容量，导致**扩容**：此时Golang会**在另一个内存地址上创建一个新的底层数组**，新数组的容量大小会比原始的数组容量大。这时，**新切片指向的是这个新数组，而不是原来的数组了**，所以对新切片和新数组进行操作，不会影响到原数组和原切片。

  * 添加后，长度未超过原始容量，**不会导致扩容**：此时Golang**不会创建新的数组**，**新切片指向的也是原来的数组**。值得注意的是，由于依旧指向原数组，那么向原切片添加新元素后，**会覆盖掉原数组对应位置的元素**，使它们成为**新元素值**。

    ```go
    	arr := [...]int{1, 2, 3, 4, 5, 6}
    	s1 := arr[:5]
    	s2 := append(s1, 10) // 此次向原切片添加元素并没有触发扩容，所以新切片依旧指向原数组，并且覆盖了原数组中的对应元素
    	s2[4] = 100
    	fmt.Println(arr)
    	fmt.Println(s1)
    	fmt.Println(s2)
    	fmt.Println(cap(s1), cap(s2))
    ```

    上述代码输出为：

    ```go
    	[1 2 3 4 100 10]
    	[1 2 3 4 100]
    	[1 2 3 4 100 10]
    	6 6
    ```

# 指针

* 若**两指针的值**相同，那么这两个指针就相同：

  ```go
  	s := 1
  	point1 := &s
  	point2 := &s
  	if point1 == point2 {
  		fmt.Println("yes")
  	}
  ```

  上述代码打印结果为“yes”

* **使用指针作为方法的接收者的策略**应该是**一致**的：若一个方法使用了某个类型的指针作为接收者，那么**该类型的所有方法**都应该使用**它的指针**作为接收者。

* 除了`map`和`slice`类型，其余类型的指针都可以进行**自动解引用**，毕竟在Go语言中，`map`和`slice`属于**隐式指针**。

* 若一个接口变量未被赋值，那么它的**类型和值**都是**`nil`**；并且只有在它的**类型和值都为`nil`**时，该接口变量才等于`nil`。

# 错误、异常、panic

* 使用`panic`比使用`os.Exit()`更好，因为`panic`后**依旧会执行`defer`的操作**。
* 若**`defer`的操作**中调用了**`recover()`**函数，那么`panic`将会停止，程序将继续运行。

# 并发

### goroutine

* **goroutine**是Golang中**独立的任务**，它和协程、线程等有相似之处，但又不完全相同。
* 当`main`函数返回的时候，**`main`函数执行的所有goroutine都会停止**。
* 在`main`函数返回之前，**所有的goroutine都会占用内存！！！**

### 通道

* 通道用于**在多个goroutine之间传输数据**。
* 通道两端的goroutine是同步工作的：
  * 通道的传输者**在传输完数据后，会一直等待**，直到通道的另一端的**某个goroutine尝试从通道接受数据。**
  * 通道的接收者**会一直等待**，直到通道的另一端的**某个goroutine尝试向通道传输数据**，接收者在接收完数据后，才会进行下一步工作。

### 互斥锁

* 尝试对一个已经上锁的互斥锁加锁，会**被阻塞**
* 尝试对一个已经解锁的互斥锁解锁，会**触发`panic`**，同时这种`panic`是`recover()`函数所**不能恢复**的。

# 垃圾回收机制

* Golang拥有自己的garbage collector（垃圾回收机制），开发时可以不手动释放资源

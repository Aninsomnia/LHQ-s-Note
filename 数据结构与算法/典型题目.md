# 二进制相关操作

* 判断一个数**是否为2的幂**

  * 如果一个数为2的幂，那么**其二进制表示中，只有一位为1，其余位全为0**。

    * **我们可以判断`n & (n-1)`的值是否为0，若为0，则n为2的幂：**

      假设 **$n$ 的二进制表示为 $(a 10\cdots 0)_2$**，其中 $a$表示若干个高位，$1$ 表示最低位的那个 $1$，$0\cdots 0$ 表示后面的若干个 $0$，那么 **$n−1$ 的二进制表示为：$(a 01\cdots1)_2$**

      我们将 **$(a 10\cdots 0)_2$与 $(a 01\cdots1)_2$进行按位与运算**，高位 $a$ 不变，在这之后的所有位都会变为 $0$，这样我们就将最低位的那个 $1$移除了。**如果此时高位$a$中还有1，那么说明n不是2的幂。**

    * **我们可以判断`n & (-n)`的值是否为n，若为n，则n为2的幂：**

      假设 **$n$ 的二进制表示为 $(a 10\cdots 0)_2$**，其中 $a$ 表示若干个高位，$1$ 表示最低位的那个 $1$，$0\cdots 0$ 表示后面的若干个 $0$，那么 $-n$ 的二进制表示为：

      ​												**$(\bar{a} 01\cdots1)_2$ + $(1)_2$ = $(\bar{a} 10\cdots0)_2$**

      其中 $\bar{a}$表示将 $a$ 每一位取反。我们将 $(a 10\cdots 0)_2$与 $(\bar{a} 10\cdots0)_2$进行按位与运算，**高位全部变为 $0$，最低位的 $1$ 以及之后的所有 $0$ 不变，这样我们就获取了 $n$ 二进制表示的最低位的 $1$**。如果此时结果依然是$n$，**说明$n$的高位$a$全为$0$，也就说明了n是一个2的幂。**

# 表达式转换

* 中缀转后缀
  * 左优先：只要中缀中左边的运算符能先运算，则先转换左侧的运算符
  * 由于中缀表达式运算符顺序在后缀中就是**从左往右**排列的，而从左往右的顺序就是操作符栈的出栈顺序，**那么该算法中维护的操作符栈就是一个优先级从栈顶到栈底严格减小的单调栈**。                           
    * 从左往右遍历中缀表达式。
      * 若遇到操作数，直接加入后缀表达式。
      * 若遇到操作符，判断与当前栈顶操作符的优先级。**若栈顶操作符优先级高或等于，则出栈，加入后缀表达式。反之直接入栈。**
      * 若遇到左括号，直接入栈。若遇到右括号，总是将栈顶运算符加入后缀表达式，直到栈顶为左括号。
      * 简单来说，之前的运算符级别高，之前的就要先算，就要先加入到后缀表达式中。
* 中缀转前缀
  * 右优先：只要中缀中右边的运算符能先运算，则先转换右侧的运算符
* 两种优先方式都是为了**统一后缀（前缀）表达式的形式**，即**中缀表达式中的自然运算顺序直接体现在后缀（前缀）表达式中运算符的左右次序里面**。①中缀表达式运算符顺序在后缀中就是**从左往右**排列的。②中缀表达式运算符顺序在后缀中就是**从右往左**排列的。

# 表达式求值

* 中缀表达式
  * 设置两个栈，**一个操作数栈，一个操作符栈**
  * 遍历表达式
    * **若遇到操作数，将其压入操作数栈中**
    * **若遇到操作符，将其与操作符栈的栈顶元素比较优先级**
      * **若后来的优先级高，则将其入栈，什么都不做**
      * **若栈顶操作符的优先级高，则将先前的操作符和操作数栈顶的两个操作数出栈，进行运算，将结果压入操作数栈。再将新的操作符入栈。**
      * 若遇到左括号，总是压栈；若遇到右括号，总是将先前的操作符进行运算，直到栈顶为左括号。（也就是说，左括号不考虑优先级，右括号优先级最低）。并且遇到右括号时，若操作符栈顶是左括号，两者抵消。
  * 遍历结束后依次将操作符栈栈顶元素和操作数栈顶的两个操作数出栈，进行运算，将结果压入操作数栈。直至**操作符栈为空**。这时操作数栈中唯一的元素就是结果。
  * 中缀的运算和中缀转后缀大致上都是同一个道理，即**优先级高的运算符，就要先算（或者先加入到后缀表达式中**），这意味者，两个算法中维护的都是一个**优先级从栈顶到栈底严格减小的单调栈**。
* 后缀表达式
  * 手算：从左往右依次遍历，每遇到一个运算符，就让运算符前面最近的两个操作数运算，合成为一个新的操作数。
  * 算法：使用一个操作数栈
  * 遍历表达式：
    * **若遇到操作数，将其压入操作数栈中**
    * **若遇到操作符，则弹出操作数栈顶两个元素，进行运算，将结果压入操作数栈中**
  * 遍历结束后，操作数栈中那个唯一元素就是最终结果
* 前缀表达式
  * 算法大致同于后缀表达式，但是是从右往左遍历表达式。
  * 注意：后缀表达式运算中，先出栈的元素为右操作数。前缀表达式运算中，先出栈的元素为左操作数。

# 使用两个栈实现队列

* 栈：先进后出。队列：先进先出：

  所以：创建两个栈：栈A和栈B，栈A负责队列的添加操作，栈B负责队列的删除操作

* 添加元素时【add()或offer()】：

  * 栈A执行push()。

* 返回并弹出元素时【remove()或 poll()】：

  * 首先判断栈B是否为空：
    * 若栈B为空：判断栈A是否为空
      * 若栈A不为空：则将栈A中的元素出栈并入栈到栈B，再将栈B中元素出栈。
      * 若栈A为空：则抛出异常（因为此时逻辑上队列中为空）。
    * 若栈B不为空，则直接将栈B中元素出栈。

*  返回队列头部元素时【element()或peek()】：

  * 使用一个变量存储最后一个入队列的元素，直接返回该变量的值。

* **注意：在从栈A中出栈并向栈B中入栈时，必须在栈B为空执行这操作，否则出队列的顺序将发生错误。**

# 使用两个队列实现栈

* 创建两个队列，在任何空闲时刻都只有一个队列中有元素。
* 添加元素时【push()】：
  * 向那一个非空队列中添加元素
* 弹出元素时【 pop()】：
  * 将非空队列中个数为（元素数量-1）的元素出队列到另外一个队列中，并将剩下的那个元素作为出栈的元素弹出。**（此时该队列又称为新的空队列，另一个队列成为了新的非空队列）**

# 链表

* 双链表头部插入

  ```java
      public ListNode add2(ListNode L, ListNode x)//将结点x插入到头部
      {
        if(L.next == null)
        {
          *L*.next = *x*;
          *x*.pre = null;
          *x*.next = null;
        }
        else
        {
          *L*.next.pre = *x*;
          *x*.next = *L*.next;
          *L*.next = *x*;
        }
      }
  ```

* 双链表任意位置插入

  ```java
      public void add(ListNode *x*, ListNode *y*)*//将结点x插入到y的前面*
      {
        *x*.pre = *y*.pre;
        *x*.next = *y*;
        *y*.pre.next = *x*;
        *y*.pre = *x*;
      }
  ```

* 删除结点x

  ```java
      public void del(ListNode *x*)*//删除结点x*
      {
        *x*.pre.next = *x*.next;
        *x*.next.pre = *x*.pre;
      }
  ```

# 快慢指针

* 快慢指针有**两种条件判断方式**：

  * ```java
    while(fast != null && fast.next != null)
    ```

  * ```java
    while(fast.next != null && fast.next.next != null)
    ```

  * 使用第一种方式时，最后**slow指针指向的是后半部分链表的头结点**。

  * 使用第二种方式时，最后**slow指针指向的是前半部分链表的尾结点**，slow.next指向的才是后半部分链表的头结点。

* 什么时候该用哪种方式呢？首先要明白一点：当链表长度为**奇数**时，无论使用上述哪一种方式，**slow指针都指向最中间那一个结点**。

  * 长度为**奇数**时，若最中间结点应该算**前半部分的结尾**：那么此时后半部分开头结点就应是`slow.next`，应该选用第二种方式。
  * 长度为**奇数**时，若最中间结点应该算**后半部分的开头**：那么此时后半部分开头结点就应是`slow`，应该选用第一种方式。

# 二叉树

* 先序遍历

  ```java
  class Solution {
      public List<Integer> preorderTraversal(TreeNode root) {
          List<Integer> ans = new ArrayList<Integer>();
          preOrder(ans, root);
          return ans;
      }
      
      public void preOrder(List<Integer> list, TreeNode root) {
          if(root != null)
          {
              list.add(root.val);
              preOrder(root.left);
              preOrder(root.right);
          }
      }
  }
  ```

# 二叉树中任意结点的中序前驱结点

* 从根节点开始进行一次完整的中序遍历，**使用$pre$指针记录当前节点的前驱结点，使用$cur$指针记录当前结点**。当$target==cur$时，$pre$便是前驱结点。
* 使用线索二叉树。

# 二叉排序树（BST）

* 查询算法

  ```java
  //非递归算法
  class Solution {
      public TreeNode searchBST(TreeNode root, int val) {
          while(root != null && root.val != val)
              root = root.val > val ? root.left : root.right;
          return root;
      }
  }
  //递归算法
  class Solution {
      public TreeNode searchBST(TreeNode root, int val) {
          if(root == null || root.val == val)
              return root;
          return searchBST(root.val > val ? root.left : root.right, val);
      }
  }
  ```

* 插入算法（**这个算法告诉我们，若要改变子结点或新创子结点，必须要在父结点处执行，否则子结点无法得到更改**）

  ```java
  //非递归算法
  class Solution {
      public TreeNode insertIntoBST(TreeNode root, int val) {
          TreeNode head = root;
          if(root == null)
              {
                  root = new TreeNode(val);
                  return root;
              }
          while(root != null && root.val != val)
          {
              if(root.val > val)
              {
                  if(root.left == null)
                  {
                      root.left = new TreeNode(val);
                      break;
                  }
                  root = root.left;
              }
              else
              {
                  if(root.right == null)
                  {
                      root.right = new TreeNode(val);
                      break;
                  }   
                  root = root.right;
              }
          }
          return head;
      }
  }
  //递归算法
  class Solution {
      public TreeNode insertIntoBST(TreeNode root, int val) {
          if(root == null)
              return new TreeNode(val);
          if(root.val > val)
              root.left = insertIntoBST(root.left, val);
          else
              root.right = insertIntoBST(root.right, val);
          return root;
      }
  }
  ```
  
* 删除算法

  ```java
  class Solution {
      public TreeNode deleteNode(TreeNode root, int key) {
          if(root == null)
              return null;
          if(root.val == key)
          {
              if(root.left == null && root.right == null)
                  return null;
              else if(root.left != null && root.right != null)
              {
                  TreeNode tmpRoot = root.left;
                  while(tmpRoot.right != null)
                      tmpRoot = tmpRoot.right;
                  root.val = tmpRoot.val;
                  root.left = deleteNode(root.left, tmpRoot.val);
                  return root;
              }
              else
                  return root.left == null ? root.right : root.left;
          }
          else if(root.val > key)
              root.left = deleteNode(root.left, key);
          else
              root.right = deleteNode(root.right, key);
          return root;
      }
  }
  ```


# 网格问题中的DFS、BFS

### 网格问题中的DFS

* **和二叉树的DFS类比**：

  * 二叉树的DFS：

    ```java
    public void dfs(TreeNode root) {
        // 判断 空结点
        if (root == null) {
            return;
        }
        // 访问两个相邻结点：左子结点、右子结点
        dfs(root.left);
        dfs(root.right);
    }
    ```

    可以看出，二叉树dfs有两个基本的部分：**「访问相邻结点」**和**「判断临界条件」**。对于二叉树来说，**临界条件就是遍历到某个叶结点下的空结点，此时就应该停止遍历**；而每个结点的相邻结点只有其左右两个孩子结点，所以**访问相邻结点就是访问两个孩子结点**。

  * 而对于一个网格来说，临界条件就是**某个格子超出了该网格的范围**；而一个格子（r，c）的相邻格子有四个，分别是：**（r-1，c）、（r+1，c）、（r，c-1）和（r，c+1）**。所以类比二叉树的DFS，网格问题中的DFS基本框架应该是：

    ```java
    public void dfs(int[][] grid, int r, int c) {
        // 判断 是否超出网格范围
        if (!inArea(grid, r, c)) {
            return;
        }
        // 访问两个相邻结点：左子结点、右子结点
        dfs(grid, r-1, c);
        dfs(grid, r+1, c);
        dfs(grid, r, c-1);
        dfs(grid, r, c+1);
    }
    public boolean inArea(int[][] grid, int r, int c){
        if(r >= 0 && r <= grid.length-1 && c >= 0 && c <= grid[0].length-1)
            return true;
        return false;
    }
    ```

* **如何避免重复访问**：和二叉树不同，图或者网格（也算是一种特别的图）的遍历**存在着重复访问的问题**，故而要**将已经访问过的结点进行标记**。可以使用**额外的标记数组visited[]**，也可以在**原图上进行标记**。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。也就是说，每个格子可能取三个值：

  - 0 —— 海洋格子
  - 1 —— 陆地格子（未遍历过）
  - 2 —— 陆地格子（已遍历过）

  在代码中加入以下判断语句：

  ```java
      if (grid[r][c] != 1) {
          return;
      }
  ```

### 网格问题中的BFS

* 和二叉树BFS类似，我们需要一个存储二元组的队列，来存储每一层的格子。
* **相邻结点和临界条件**的判断，都和上文**网格问题中的DFS**对应部分完全一样。当从队列中出队一个格子时，对它四个方向相邻的格子进行判断，将那些**处于网格范围内的、未访问过的格子**添加到队列中，并且将它们的内容进行标记。
* **避免重复访问的方法**也可以和上文使用同样的方法。
* 此外，还有一种避免重复访问的方法，那就是**记录每一个访问过的格子距离源点（或者源点集）的距离**。
  * **使用数组`d[][]`，`d[i][j]`表示的是`grid[i][j]`这个格子距离源点集的距离**，初始化时所有非源点集的格子距离为INF无限大，若中途访问某一格子时发现该格子的**`d[i][j]`不为INF**，则说明**之前某个时刻已经访问过该格子**。
  * 对于某一个格子`grid[i][j]`的四个邻接格子`grid[r][c]`，只有满足**`d[r][c] > d[i][j] + grid[r][c] `才能入队**（或者说**满足这个判断条件的才是未访问过的格子**，因为未访问过的格子`d[i][j]`为INF）。
  * **入队后**更新`d[r][c] = d[i][j] + grid[r][c] `。

# 背包问题——典型的动态规划问题

### 01背包——求可获得的最大价值

* 背包容量有限，每种物品**只有一个**。

* **每个物品无非是装入背包或者不装入背包，那么就一个一个物品陆续放入背包中。**也就是说动态规划的顺序是**物品数从少到多**，**背包容量从小到大**。

* 设背包容量为capacity，物品价值所构成的数组为nums[]。

* 维护一个二维数组，横向背包容量从0到capacity，纵向物品个数从0到nums.length。**数组中任意一个单元格[i, j]表示的是在背包容量为j，物品为前i个物品时，能够装下的最大价值。**

* 故[i, j] = ①**整个包都装不下第i个物品，无法将其装进去**，那么**该单元格和“背包容量同为j，物品个数i-1”的单元格价值相同。**②**整个背包可以装进该物品，但是装了该物品的最大价值和不装该物品的最大价值不同**，那么该单元格应为max{“**背包容量同为j，物品个数i-1的价值**”， “**背包容量为  ’装了第i个物品剩下的容量‘  ， 物品个数为i-1时的最大价值，再加上第i个物品的价值**”}

* 假设第i个物品的大小为W(i)，价值为V(i)。：
  * 整个背包都装不下一个物品i时：
  
    ```java
    [i, j] = [i-1, j]
    ```
  
  * 整个背包装得下物品i时：
  
    ```java
    [i, j] = max{[i-1, j],  [i-1,j-W(i)] + V(i)}
    ```
  
* 其实这也是一种贪心算法，在每一步时，**都求出当前情况下的最优解，同时，当前的最优解又是最终问题最优解的一部分。**

* 上面的递推式可以总结为**：①：j >= W(i) 时，[i, j] = max{[i-1, j],  [i-1,j-W(i)] + V(i)}  ② j < W(i) 时，[i, j] = [i-1, j]**。可以看到，当我们要计算第`i`层的数据时，只会用到第`i-1`层的数据，也就是说我们完全可以使用**滚动数组**甚至**一维数组**在存储相关数据解决该问题。

  * **使用一维数组**：假设当我们从对第i=1层**从前往后**遍历时，其中数组前面部分是属于 i=2 层的状态值，后面部分属于 i=1 层的状态值，此后我们想要计算某个值时，很有可能要用到第1层的某个值，但**那个值恰好又被刚刚第i=2层的数据覆盖掉了**，此时算出来的答案就是错误的。所以想要使用一维数组解决01背包问题，就必须**从后往前**遍历每一层数据，因为**下一层的计算只会使用到前一层中、下标靠前的那些数据**，而下标在其后的那些数据则用不到。此时的递推公式就为：**：①：j >= W(i) 时，[j] = max{[j],  [j-W(i)] + V(i)}  ② j < W(i) 时，[j] = [j]**。
  * **使用滚动数组**：在使用一维数组时，在每一层遍历中，**要考虑被覆盖的上一层元素，在该层遍历还会不会再被需要到（例如在01背包问题中，所需要的上一层元素总是在左侧，所以遍历可以从右往左进行）**。而使用滚动数组时，就不必考虑这一点，**只需要当该层的数据写入新数组后，将新数组覆盖老数组**，从而实现数组的滚动使用。

### 完全背包

* 背包容量有限，但是和01背包问题唯一不同的是：每种物品**有无限个**，在选择的时候，物品的个数上限为`j/W(i)`。可以看出，**01背包是完全背包的一个特例**。

* 假设第i个物品的大小为W(i)，价值为V(i)。：

  * 整个背包都装不下一个物品i时：

    ```java
    [i, j] = [i-1, j]
    ```

  * 整个背包装得下物品i时：

    ```java
    [i, j] = max{[i-1, j],  [i-1,j-k*W(i)] + k*V(i)}   (0 <= k <= j/W(i))
    //这是从：当前容量可以装多少个物品i？这一点出发
    //或者
    //容量j-W(i)的最大价值为[i, j-W(i)]，那么再多装一个物品i，就可以凑满总价值j。
    [i, j] = max{[i-1, j],  [i,j-W(i)] + V(i)}
    ```

* 同样，**下一层的计算只会使用到前一层中、下标靠前的那些数据**，所以这时也可使用一维数组来进行计算。

  * 整个背包都装不下一个物品i时：

    ```java
    [j] = [j]
    ```

  * 整个背包装得下物品i时：

    ```java
    [j] = max{[j - k*W(i)] + k*V(i), [j]}
    ```

### 多重背包

* 和完全背包问题类似，不过物品的数量变为有限个,那么在遍历时，每个物品选择的个数上限为`nums[i]`和`j/W(i)`较小的哪一个。

* 假设第i个物品的大小为W(i)，价值为V(i)。：

  * 整个背包都装不下一个物品i时：

    ```java
    [i, j] = [i-1, j]
    ```

  * 整个背包装得下物品i时：

    ```java
    [i, j] = max{[i-1, j],  [i-1,j-k*W(i)] + k*V(i)}   (0 <= k <= nums[i] && 0 <= k <= j/W(i))
    ```

* 完全背包和多重背包在遍历时，每个物品最多取`k`个，那么就要比较`k`次，而01背包作为特例，每个物品最多取一个，只需要比较一次。

# 背包问题总结

* 以上三个问题所求目标都是“所装元素的最大和”，但其实背包问题还有很多变种:

  * 以物品个数分类：**01背包、多重背包、完全背包、组合背包、分组背包**。
  * 以所求目标分类：**最值问题、存在问题、组合问题**。

* **背包最多装多少？（或者问背包能否装满？）**：

  * 二维表达为：

    ```java
    dp[i][j] = max{d[i-1][j], d[i-1][j-W(i)]+V(i)}
    ```

    一维表达为：

    ```Java
    dp[j] = max{dp[j], dp[j-W(i)]+V(i)}
    ```

* **装满背包有几种方法？**

  * 二维表达为：

    ```java
    dp[i][j] = dp[i-1][j] + dp[i-1][j-W(i)]
    ```

  * 一维表达为：

    ```java
    dp[j] = dp[j] + dp[j-W(i)]
    ```

* **装满背包的物品最少数量？**

  * 二维表达为：

    ```java
    dp[i][j] = min{dp[i-1][j], dp[i-1][j-W(i)]+1}
    ```

  * 一维表达是：

    ```java
    dp[j] = min{dp[i-1], dp[j-W(i)]+1}
    ```


# 最大子数组/最小子数组/和的绝对值最大的子数组

### 最大子数组：

* 设`dp[i]`表示**以`nums[i]`结尾的最大子数组和**，那么新元素的最大子数组，要么**和上一个最大子数组合并**、要么**“自立门户”从该元素重新开始**：

  ```java
  dp[i] = max{dp[i-1] + nums[i], nums[i]};
  ```

* 若要使用**常量级空间复杂度**，只需要维护一个值`dp`：

  ```java
  dp = dp < 0 ? nums[i] : dp+nums[i];
  ```

* 若要返回最大子数组的左右界限，需要一个维护一个变量begin，当**每次以新下标元素做开头“自立门户”时更新begin，而出现新的最大值时，begin就是该最大子数组的左边界**：

  ```java
  int dp = -1;
  int begin = 0;
  int max = Integer.MIN_VALUE;
  int[] ans = new int[2];
  for(int i = 0; i < nusm.length; i++)
  {
  	if(dp >= 0)
  		dp += nums[i];
  	else
  	{
  		dp = nums[i];
  		begin = i;
  	}
  	if(max < dp)
  	{
  		max = dp;
  		ans[0] = begin;
  		ans[1] = i;
  	}
  }
  ```

### 最小子数组：

* 设`dp[i]`表示**以`nums[i]`结尾的最小子数组和**，那么：

  ```java
  dp[i] = min{dp[i-1] + nums[i], nums[i]};
  ```

### 和的绝对值最大的子数组：

* 我们可以**使用动态规划求出和最大、和最小的子数组，那么和的绝对值最大的子数组一定就是两者中的一个**：

  ```java
  maxdp[i] = max{maxdp[i-1] + nums[i], nums[i]};
  mindp[i] = min{mindp[i-1] + nums[i], nums[i]};
  max = max(max, abs(maxdp[i]));
  max = max(max, abs(mindp[i]));
  ```

* 我们也可以使用前缀和，既然是绝对值最大，那么我们只需要找到前缀和中**最大的前缀和prefix[i]**，以及**最小的前缀和prefix[j**]，直接两者相减取绝对值即可，而**不必考虑i是否大于j、或者i是否小于j**：

  ```java
  max = abs(prefix[i] - prefix[j]);
  ```

# 最大子矩阵问题：

* 二维情况下的最大子矩阵问题，可以转化为一维下的最大子数组问题。
* 对于矩阵中的**第top行**到**第bottom行**，我们可以**将这一个子矩阵压缩成一个一维数组**，数组长度为矩阵的列数，然后在对这一个一维数组**求其最长子数组**。求得的这一个**左边界为left、右边界为right的最大子数组**，**二维下就是一个上界为top、下界为bottom、左边界为left、右边界为right的最大子矩阵**。我们使top和bottom**遍历整个矩阵的所有行**，途中维护最大子矩阵的值，遍历结束后，便可获得整个矩阵的的最大子矩阵。

# 最长公共子序列（LCS）/最长公共字串问题

### **最长公共子序列（LCS）：**

* 设**`dp[i][j]`为`S_1[0~i]`，`S_2[0~j]`这两个前缀子串的LCS长度**。那么，当：
  * ①**`S_1[i]=S_2[j]`时，`dp[i][j] = dp[i-1][j-1]+1`**。因为**S1的第i个字符和S2的第j个字符相同**，那么这两个前缀的LCS完全可以写作**`S_1[0~i-1]`，`S_2[0~j-1]`这两个前缀的LCS再附上那个相同的字符**。
  * ②**`S_1[i]!=S_2[j]`时，`dp[i][j] = max(dp[i-1][j], dp[i][j-1]) `**。因为如果S1的第i个字符和S2的第j个字符不相同，那么**这两个字符中至少有一个不被包含在`S_1[0~i]`，`S_2[0~j]`这两个前缀的LCS中**（也就是说`S_1[i]`和`S_2[j]`两个字符中，不可能同时是LCS的最后字符）。那么，当我们**任意去掉两个中的一个**：
    * （1）去掉`S_1[i]`，那么`S_1[i-1]`和`S_2[j]`**说不定就相同了**，这两个字符就可以成为新前缀`S_1[0~i-1]`，`S_2[0~j]`的LCS中的末尾。
    * （2）去掉`S_2[j]`，那么`S_1[i]`和`S_2[j-1]`**说不定就相同了**，这两个字符也可以成为新前缀`S_1[0~i]`，`S_2[0~j-1]`的LCS中的末尾。
  * 求出两对新前缀的LCS长度后，原来的那对前缀`S_1[0~i]`，`S_2[0~j]`的LCS长度就是**两者中大的那一个**。
* 因为在求`dp[i][j]`、`dp[i-1][j]`以及`dp[i][j-1]`时，都会求`dp[i-1][j-1]`的值，所以这其中就存在者**重复子问题**，那么就必须使用**动态规划思路**来减少时间开销。

### 最长公共字串：

* 设`dp[i][j]`为**以`S_1[i]`，`S_2[j]`这两个字母共同结尾的最大字串长度**。显而易见，**当两个字符不相同时，没有最长字串，因为同时以这两个字符结尾的字串不存在**。
  * ①`S_1[i]=S_2[j]`时，`dp[i][j] = dp[i-1][j-1]+1`。因为**S1的第i个字符和S2的第j个字符相同**，那么这两个前缀的、以这两个字符共同结尾的最长字串完全可以写作**`S_1[0~i-1]`，`S_2[0~j-1]`这两个前缀的、以`S_1[i-1]`和`S_2[j-1]`两个字符共同结尾的最长字串，再附上那个相同的字符**。
  * ②`S_1[i]!=S_2[j]`时，`dp[i][j] = 0`。道理显而易见，**当两个字符不相同时，没有以这两个字符共同结尾的最长字串，因为同时以这两个字符结尾的字串不存在**。
* 同求LCS问题，这其中也存在重复子问题，也需要使用动态规划解决问题。

# 最长递增子序列(LIS)

* 设`dp[i]`意为：以**nums[i]结尾的最长严格递增子序列长度**。

* ```java
  dp[i] = max{dp[j], 1}+1   (0 <= j < i && nums[j] < nums[i])
  ```

# 有效括号字符串匹配

* 使用**动态规划**：`dp[i][j]`表示**开头下标为`i`，结尾下标为`j`**的子串**是否为一个有效括号字符串**。
  * `i == j`时，单个字符不可能为有效字符串，**故`dp[i][j]`为false**。
  * `j == i+1`时，**只有`str[i] == '(' && str[j] == ')'`时才为有效字符串**，否则为无效。
  * 其他情形时则要分为两种情况：
    * 若`str[i] == '(' && str[j] == ')'`，则说明两边外围的括号是有效的，此时就要看内部是否也是有效的括号字符串：**`dp[i][j] = dp[i+1][j-1]`**。
    * 此时还要判断是否存在一个值**`k (i <= k && k+1 <= j)`**，若**`dp[i][k] & dp[k+1][j] == true`**，说明从i到j可以分割为两个有效的括号字符串，那么`dp[i][j]`自然为true。
* 使用**栈**：维护一个**左括号栈**。
  * 遇到**左括号，入栈**。
  * 遇到**右括号，判断栈是否为空**：若不空，则栈中**存在可与其匹配的左括号，将栈顶元素出栈**；若为空，说明**该右括号之前已没有可与其匹配的左括号，返回false**（违背了**“左括号 `(` 必须在对应的右括号之前 `)`”**这一前提条件）。
  * 遍历结束后，**判断栈是否为空**：若不空，则说明**存在多余的左括号无法匹配，返回false**；若为空，则说明**整个字符串左括号右括号全都可以匹配，字符串为有效括号字符串，返回true**。
* 贪心算法：遍历字符串过程中，左括号的未匹配数量`count`会发生变化：
  * 如果遇到**左括号**，则**未匹配的左括号数量加 1**。
  * 如果遇到**右括号**，则**需要有一个左括号和该右括号匹配，因此未匹配的左括号数量减 1**。
  * 若在遍历过程中途，**未匹配左括号数量为负**，说明此时此刻存在一个右括号，**在其左边没有多余的左括号能与其匹配，返回false**（违背了**“左括号 `(` 必须在对应的右括号之前 `)`”**这一前提条件）。
  * 若在遍历结束后，未匹配左括号数量为正，说明结束后存在多余的左括号无法匹配，返回false。
  * 只有在遍历结束后，未匹配左括号数量为0，才说明整个字符串的左括号和右括号都能匹配。

# 子序列匹配

* 设$dp[i][j]$为**从下标为$i$的位置开始，字符$j$第一次出现的位置**。

  * 当$str[i] == j$时，$dp[i][j] = i$
  * 当$str[i] != j$时，$dp[i][j] = dp[i+1][j]$

* ```java
  int m = s.length();        
  int[][] dp = new int[m+1][26];       	
  Arrays.fill(dp[m], m);        
  for (int i = m-1; i >= 0; i--) {        
      for (int j = 0; j < 26; j++) {        
          if(s.charAt(i) == (char)('a'+j))        
              dp[i][j] = i;        
          else        
              dp[i][j] = dp[i+1][j];        
      }        
  }
  ```

* 当要判断另一个字符串$t$是否为$s$的子序列时：需要判断$t$中的每一个字符，都能在$s$中找到存在的下标。

  ```java
      public boolean isSubString(int[][] dp, String subString) {
          int j = 0;
          for (int i = 0; i < subString.length(); i++) {
              if(dp[j][subString.charAt(i)-'a'] == dp.length-1)
              {
                  return false;
              }
              else
              {
                  j = dp[j][subString.charAt(i)-'a']+1;
              }
          }
          return true;
      }
  ```

  